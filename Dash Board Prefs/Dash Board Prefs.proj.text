// Text of project Dash Board Prefs.proj written on 6/29/13 at 10:45 PM// Beginning of text file Constants.txtconstant kVsn := "1.5.2013d1";constant kVsnStr := "Dash Board Prefs" && kVsn;constant kDBSym := '|DashBoard:FiveSpeed|;// End of text file Constants.txt// Beginning of text file Strings.txt//strings used with ParamStr()constant kMenuItemHelpStr := "The selected item is a ^0. Choosing \"^1\" from the menu ^2";constant kMoveHelp := "You can move it within the menu by dragging it, or remove it by tapping the Remove Selected Item button.";// End of text file Strings.txt// Beginning of text file DoNotInstall.txtSetPartFrameSlot('DoNotInstall, func() //return TRUE if not strongarm	begin		local g := Gestalt(kGestalt_SystemInfo);		if g.cputype = 'strongarm then			begin				return NIL;			end		else			begin				GetRoot():Notify(kNotifyALert, TotalClone("Dash Board Prefs"), TotalClone("Sorry, Dash Board Prefs can only be installed on MessagePad 2000 or MessagePad 2100 machines."));				return TRUE;			end;	end;);// End of text file DoNotInstall.txt// Beginning of file modalator.tmodalator :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 512,     viewFormat: 0,     viewJustify: 240,     viewClass: 74 /* clView */    };constant |layout_modalator.t| := modalator;// End of file modalator.t// Beginning of file panel_tab.protomyTab :=    {viewBounds: {left: 64, top: 56, right: 128, bottom: 72},     viewFlags: 513,     viewFormat: 0,     TabActivate:       func()       begin       	bottomHider:Open();       	SetValue(tabBorder, 'viewFillPattern, tabActiveFill);       	SetValue(tabTextHolder, 'viewFont, tabFontActive);       	SetValue(tabTextHolder, 'viewFillPattern, tabActiveFill);       	//customshit for DB prefs below       	:Parent():SwitchTab(self.mySym);       	//myPanel:Open();       	panelHolder:OpenPanel(mySym);       end,     TabDeactivate:       func()       begin       	if bottomHider.viewCObject then bottomHider:Hide();       	SetValue(tabBorder, 'viewFillPattern, tabInactiveFill);       	SetValue(tabTextHolder, 'viewFillPattern, tabInactiveFill);       	SetValue(tabTextHolder, 'viewFont, tabFontInactive);       	TabIsActive := nil;       	       	//custiom sheeat for db prefs below       	       	if self.myPanel.viewCobject then myPanel:Close();       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       self.TabIsActive := nil;       	inherited:?ViewSetupFormScript();       end,     tabDeactivateScript:       func()       begin       end,     tabActivateScript:       func()       begin       end,     viewClickScript:       func(unit)       begin       Clicker();       if TabIsActive = nil then       	begin       		:TabActivate();       		:tabActivateScript();       		TabIsActive := true;       		end;       	// Return true if click has been completely handled, nil otherwise       end,     tabActiveFill: kRGB_Gray0,     tabInactiveFill: kRGB_Gray4,     tabFontActive: ROM_fontSystem10Bold,     tabFontInactive: ROM_fontsystem9,     tabText: "A Tab",     TabActivateTabOnly:       func()       begin       	//bottomhider is NIL after ShowBtnBar op, causing 48809 crash (open undefined method cuz it nil view)...       	       	bottomHider:Open();       	SetValue(tabBorder, 'viewFillPattern, tabActiveFill);       	SetValue(tabTextHolder, 'viewFont, tabFontActive);       	SetValue(tabTextHolder, 'viewFillPattern, tabActiveFill);       	//customshit for DB prefs below       	:Parent():SwitchTab(self.mySym);       	       	//panelHolder:OpenPanel(mySym); //THIS LINE DELTED for TabOnly version (panel already open);       end,     viewClass: 74 /* clView */    };tabBorder :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewFlags: 1,     viewFormat: 67109470,     viewJustify: 240,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.viewFillPattern := kRGB_Gray4;       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(myTab, tabBorder);StepDeclare(myTab, tabBorder, 'tabBorder);bottomHider :=    {viewBounds: {left: 2, top: -2, right: -2, bottom: 0},     viewFlags: 0,     viewFormat: 1,     viewJustify: 176,     viewClass: 74 /* clView */    };AddStepForm(myTab, bottomHider);StepDeclare(myTab, bottomHider, 'bottomHider);tabTextHolder :=    {text: "Tab",     viewBounds: {left: 2, top: 3, right: -2, bottom: -2},     viewJustify: 8388854,     viewFormat: 14,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	//SetValue(self, 'viewFillPattern, tabInactiveFill);       	//SetValue(self, 'viewFont, tabFont);       	SetValue(self, 'text, tabText);       	inherited:?ViewSetupFormScript();       end,     viewFont: ROM_fontsystem9,     viewFillPattern: kRGB_Gray4,     _proto: @218 /* protoStaticText */    };AddStepForm(myTab, tabTextHolder);StepDeclare(myTab, tabTextHolder, 'tabTextHolder);constant |layout_panel_tab.proto| := myTab;// End of file panel_tab.proto// Beginning of file storeRBtn.protostoreRBtn :=    {buttonValue: 1,     viewBounds: {left: 0, top: 0, right: 0, bottom: 16},     text: "",     myIcon: nil,     myText: nil,     ok: nil,     viewJustify: 8244,     viewSetupChildrenScript:       func()       begin       	if not self.ok then hider:Open();       end,     myStore: nil,     _proto: @202 /* protoRadioButton */    };storeRBtn_v76_0 :=    {icon: nil,     viewBounds: {left: 16, top: 0, right: 32, bottom: 16},     viewFlags: 1,     viewFormat: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.icon := myicon;       	inherited:?ViewSetupFormScript();       end,     viewJustify: 6,     viewClass: 76 /* clPictureView */    };AddStepForm(storeRBtn, storeRBtn_v76_0);storeRBtn_v218_0 :=    {text: "Store Name (free K)",     viewBounds: {left: 35, top: 0, right: 0, bottom: 0},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := myText;       	if not ok then self.viewFont := {family: 'espy, face: kFaceNormal, size: 9, color: kRGB_Gray9};       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8388856,     viewFont: ROM_fontSystem9,     _proto: @218 /* protoStaticText */    };AddStepForm(storeRBtn, storeRBtn_v218_0);hider :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 512,     viewJustify: 240,     viewClickScript:       func(unit)       begin       	return TRUE;       	// Return true if click has been completely handled, nil otherwise       end,     viewClass: 74 /* clView */    };AddStepForm(storeRBtn, hider);StepDeclare(storeRBtn, hider, 'hider);hider_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 16, bottom: 16},     viewFlags: 1,     viewFormat: 1,     viewClass: 74 /* clView */    };AddStepForm(hider, hider_v74_0);constant |layout_storeRBtn.proto| := storeRBtn;// End of file storeRBtn.proto// Beginning of file btnContents.proto_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 150, bottom: 0},     viewFlags: 1,     viewFormat: 1,     text: "BtnContents",     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.viewBounds := SetBounds(0,0,StrFontWidth(text, rom_fontsystem9Bold) + 21, 0);       	inherited:?ViewSetupFormScript();       end,     viewJustify: 208,     icon: nil,     viewClass: 74 /* clView */    };_v74_0_v76_0 :=    {icon: nil,     viewBounds: {left: 0, top: 0, right: 15, bottom: 15},     viewFlags: 1,     viewFormat: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.icon := GetRoot().|DashBoard:FiveSpeed|.(:Parent().icon);       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(_v74_0, _v74_0_v76_0);_v74_0_v218_0 :=    {text: "Static Text",     viewBounds: {left: 19, top: 0, right: 0, bottom: 0},     viewJustify: 8388852,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := :Parent().text;       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(_v74_0, _v74_0_v218_0);constant |layout_btnContents.proto| := _v74_0;// End of file btnContents.proto// Beginning of file coolBtn.protocoolBtn :=    {     buttonClickScript:       func()       begin       end,     text: "",     viewBounds: {left: 18, top: 10, right: 94, bottom: 28},     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 8}]);,     myText: "CoolBtn",     viewSetupChildrenScript:       func()       begin       	local bWidth := :LocalBox().right - :LocalBox().left;       	       	btnContent.viewBounds := Setbounds(0,0, 26 + StrFontWidth(myText, ROM_FontSystem10Bold), 0);       end,     viewJustify: 8388630,     _proto: @226 /* protoTextButton */    };btnContent :=    {viewBounds: {left: 0, top: 0, right: 80, bottom: 0},     viewFlags: 1,     viewFormat: 0,     viewJustify: 214,     viewClass: 74 /* clView */    };AddStepForm(coolBtn, btnContent);StepDeclare(coolBtn, btnContent, 'btnContent);btnContent_v76_0 :=    {     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewBounds: {left: 1, top: 1, right: 19, bottom: -1},     viewFlags: 1,     viewFormat: nil,     viewJustify: 198,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.icon := :Parent():Parent().icon;       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(btnContent, btnContent_v76_0);btnContent_v218_0 :=    {text: "CoolBtn",     viewBounds: {left: 20, top: 0, right: 0, bottom: 0},     viewJustify: 8388854,     viewFont: ROM_fontSystem10Bold,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := myText;       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(btnContent, btnContent_v218_0);constant |layout_coolBtn.proto| := coolBtn;// End of file coolBtn.proto// Beginning of file coolPopupBtn.protocoolBtn :=    {text: "",     viewBounds: {left: 18, top: 10, right: 94, bottom: 28},     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 8}]);,     myText: "CoolBtn",     viewSetupChildrenScript:       func()       begin       	local bWidth := :LocalBox().right - :LocalBox().left;       	       	btnContent.viewBounds := Setbounds(0,0, 26 + StrFontWidth(myText, ROM_FontSystem10Bold), 0);       end,     viewJustify: 8388630,     popup: [],     viewFlags: 515,     _proto: @386 /* protoPopupButton */    };btnContent :=    {viewBounds: {left: 0, top: 0, right: 80, bottom: 0},     viewFlags: 1,     viewFormat: 0,     viewJustify: 214,     viewClass: 74 /* clView */    };AddStepForm(coolBtn, btnContent);StepDeclare(coolBtn, btnContent, 'btnContent);btnContent_v76_0 :=    {     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewBounds: {left: 1, top: 1, right: 19, bottom: -1},     viewFlags: 1,     viewFormat: nil,     viewJustify: 198,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.icon := :Parent():Parent().icon;       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(btnContent, btnContent_v76_0);btnContent_v218_0 :=    {text: "CoolBtn",     viewBounds: {left: 20, top: 0, right: 0, bottom: 0},     viewJustify: 8388854,     viewFont: ROM_fontSystem10Bold,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := myText;       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(btnContent, btnContent_v218_0);constant |layout_coolPopupBtn.proto| := coolBtn;// End of file coolPopupBtn.proto// Beginning of file fileSlip.tfileSlip :=    {viewBounds: {left: 0, top: 0, right: 280, bottom: 180},     viewJustify: 80,     text: "",     selectedStore: nil,     deathRow:       '[       	selectedStore,       	text,       	selectionSize,       	caller,       	tgtStore       ],     selectionSize: 0,     viewSetupDoneScript:       func()       begin       	modalator:Open();       	       	AddDeferredSend(self, 'DoSetup, nil);       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	modalator:Close();       	:DeathPenalty();       	inherited:?ViewQuitScript();       end,     caller: nil,     DoSetup:       func()       begin       	local storeList := GetStores();       	local subList := Array(Length(storeList), 0);       	local theVictims := caller:GetSelectedItems();       	local tSize := 0;       	       	foreach i in theVictims do       		begin       			local cEntry := ResolveEntryAlias(i);       			if cEntry then        				local cSize := EntrySize(cEntry);       			tSize := tSize + cSize;       			local cElement := LSearch(storeList, EntryStore(cEntry), 0, '|=|, nil);       			subList[cElement] := subList[cElement] + cSize;       		end;       		       	local storeText;       	local theIcon := GetRoot().|DashBoard:FiveSpeed|.newtIcon;       	       	local storeIndex := 0;       	foreach i in storeList do       		begin       			local storeOK := true;       			local name := i:GetName();       			local free := i:TotalSize() - i:UsedSize();       			local needed := tSize - subList[storeIndex] ;       			if i:IsReadOnly() then       				begin       					storeOK := NIL;       					storeText := name && "(store is write protected)";        				end       			else if free > needed then       				begin       					storeText := name && "(" & :ByteSize(free) && "free)";       				end       			else       				begin       					storeText := name && "(not enough space - " & :ByteSize(free) && "free," && :byteSIze(needed) && "required)";       					storeOK := NIL;       				end;       			AddStepView(rBtns, {_proto: GetLayout("storeRBtn.proto"), ok: storeOK, myText: storeText, myIcon: theIcon, buttonValue: storeIndex});       			theIcon := GetRoot().|DashBoard:FiveSpeed|.cardIcon; //after internal (element 0) the icon will be card       			storeIndex := storeIndex + 1;       		end;       		       	for i := 0 to Length(subList) - 1 do //if all scripts on same store then preset that store       		begin       			if subList[i] = tSize then       				begin       					tgtStore := storeList[i];       					rBtns:InitClusterValue(i);       				end;       		end;       	rBtns:Dirty();       	calcMsg:Close();       end,     tgtStore: nil,     _proto: @179 /* protoFloater */    };fileSlip_v229_0 :=    {title: "Dash Board File Scripts",     viewBounds: {left: 5, top: -4, right: 133, bottom: 12},     _proto: @229 /* protoTitle */    };AddStepForm(fileSlip, fileSlip_v229_0);fileSlip_v218_0 :=    {viewBounds: {left: 8, top: 20, right: 272, bottom: 60},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := :Parent().text;       	inherited:?ViewSetupFormScript();       end,     viewJustify: 0,     viewFont: ROM_fontSystem10,     _proto: @218 /* protoStaticText */    };AddStepForm(fileSlip, fileSlip_v218_0);fileSlip_v218_0 :=    {text: "Available Stores:",     viewBounds: {left: 8, top: 61, right: 120, bottom: 73},     _proto: @218 /* protoStaticText */    };AddStepForm(fileSlip, fileSlip_v218_0);rBtns :=    {viewBounds: {left: 8, top: 75, right: 276, bottom: 153},     clusterChanged:       func()       begin       	tgtStore := GetStores()[clusterValue];       end,     viewFlags: 3,     clusterValue: nil,     _proto: @203 /* protoRadioCluster */    };AddStepForm(fileSlip, rBtns);StepDeclare(fileSlip, rBtns, 'rBtns);fileSlip_v226_0 :=    {     buttonClickScript:       func()       begin       	if not tgtStore then       		:FSNotify("Please select a store from the list before filing.");       	else       		begin       			AddDeferredSend(caller, 'FileSelectedFinish, [tgtStore]);       			:Parent():Close();       		end;       end,     text: "File",     viewBounds: {left: 225, top: 157, right: 269, bottom: 170},     _proto: @226 /* protoTextButton */    };AddStepForm(fileSlip, fileSlip_v226_0);fileSlip_v226_0 :=    {     buttonClickScript:       func()       begin       	caller:SetHelp("The File operation was cancelled.");       	:Parent():Close();       end,     text: "Cancel",     viewBounds: {left: 168, top: 157, right: 212, bottom: 170},     _proto: @226 /* protoTextButton */    };AddStepForm(fileSlip, fileSlip_v226_0);calcMsg :=    {     text:       "Calculating selection size...              ",     viewBounds: {left: 0, top: 20, right: 0, bottom: 0},     viewJustify: 8388854,     viewFont: ROM_fontSystem10Bold,     viewFormat: 1,     _proto: @218 /* protoStaticText */    };AddStepForm(fileSlip, calcMsg);StepDeclare(fileSlip, calcMsg, 'calcMsg);constant |layout_fileSlip.t| := fileSlip;// End of file fileSlip.t// Beginning of file PackManNameSlip.tPackManNameSlip :=    {viewBounds: {left: 0, top: 0, right: 300, bottom: 300},     viewJustify: 80,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	modalator:open();       	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	modalator:Close();       	inherited:?ViewQuitScript();       end,     _proto: @179 /* protoFloater */    };PackManNameSlip_v229_0 :=    {title: "Export To Newton Package",     viewBounds: {left: -8, top: 3, right: 136, bottom: 19},     _proto: @229 /* protoTitle */    };AddStepForm(PackManNameSlip, PackManNameSlip_v229_0);PackManNameSlip_v218_0 :=    {     text:       "Enter the package name for the package that will contain the exported script(s). The package name should end in your unique" &&       "developer signature, or \":PackMan:ICS\" if you do not have one. The Extras Drawer name will be the name that appears in the extras drawer."     ,     viewBounds: {left: 6, top: 27, right: 294, bottom: 101},     viewJustify: 0,     viewFont: ROM_fontSystem10,     _proto: @218 /* protoStaticText */    };AddStepForm(PackManNameSlip, PackManNameSlip_v218_0);PackManNameSlip_v74_0 :=    {viewBounds: {left: 6, top: 104, right: -6, bottom: 144},     viewFlags: 1,     viewFormat: 592,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(PackManNameSlip, PackManNameSlip_v74_0);PackManNameSlip_v74_0_v218_0 :=    {text: " Package Name:",     viewBounds: {left: 0, top: 0, right: 0, bottom: 12},     viewJustify: 8388664,     viewClickScript:       func(unit)       begin       	true;       	// Return true if click has been completely handled, nil otherwise       end,     viewFormat: 14,     viewFillPattern: kRGB_Gray6,     _proto: @218 /* protoStaticText */    };AddStepForm(PackManNameSlip_v74_0, PackManNameSlip_v74_0_v218_0);nameInput :=    {viewBounds: {left: 2, top: 1, right: -2, bottom: -1},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := "MyDBScripts:PackMan:ICS";       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	sName := self;       	AddDeferredSend(self, 'SetHilite, [999,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     viewLineSpacing: 37,     viewJustify: 8388848,     viewlinepattern: kRGB_Gray7,     _proto: @185 /* protoInputLine */    };AddStepForm(PackManNameSlip_v74_0, nameInput);StepDeclare(PackManNameSlip, nameInput, 'nameInput);PackManNameSlip_v226_0 :=    {     buttonClickScript:       func()       begin       	if StrEqual("", nameInput.text) then       		:Notify(kNotifyAlert, "Dash Board Script Export", "There is no name entered. You must enter a name for the package containing the exported scripts.");       	else if StrEqual("", ExtrasNameInput.text) then       		:Notify(kNotifyAlert, "Dash Board Script Export", "There is no Extras Drawer name entered. You must enter an Extras Drawer name for the package containing the exported scripts.");       	else       		begin       			GetRoot().(kAppSYmbol).expPkgName := Clone(nameInput.text);       			GetRoot().(kAppSymbol).expPkgExtrasName := CLone(ExtrasNameInput.text);       			:Parent():Close();       		end;       end,     text: "Export",     viewBounds: {left: 234, top: 285, right: 294, bottom: 298},     _proto: @226 /* protoTextButton */    };AddStepForm(PackManNameSlip, PackManNameSlip_v226_0);PackManNameSlip_v226_0 :=    {     buttonClickScript:       func()       begin       	GetRoot().(kAppSymbol).expPkgName := NIL;              	:Parent():CLose();       end,     text: "Cancel",     viewBounds: {left: 161, top: 285, right: 221, bottom: 298},     _proto: @226 /* protoTextButton */    };AddStepForm(PackManNameSlip, PackManNameSlip_v226_0);PackManNameSlip_v375_0 :=    {viewBounds: {left: 38, top: -103, right: 263, bottom: -22},     _proto: @375 /* protoAlphaKeyboard */    };AddStepForm(PackManNameSlip, PackManNameSlip_v375_0);PackManNameSlip_v74_0 :=    {viewBounds: {left: 6, top: 151, right: -6, bottom: 191},     viewFlags: 1,     viewFormat: 592,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(PackManNameSlip, PackManNameSlip_v74_0);PackManNameSlip_v74_0_v218_0 :=    {text: " Extras Drawer Name:",     viewBounds: {left: 0, top: 0, right: 0, bottom: 12},     viewJustify: 8388664,     viewClickScript:       func(unit)       begin       	true;       	// Return true if click has been completely handled, nil otherwise       end,     viewFormat: 14,     viewFillPattern: kRGB_Gray6,     _proto: @218 /* protoStaticText */    };AddStepForm(PackManNameSlip_v74_0, PackManNameSlip_v74_0_v218_0);extrasNameInput :=    {viewBounds: {left: 2, top: 1, right: -2, bottom: -1},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := "My DB Scripts";       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	sName := self;       	AddDeferredSend(self, 'SetHilite, [999,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     viewLineSpacing: 37,     viewJustify: 8388848,     viewlinepattern: kRGB_Gray7,     _proto: @185 /* protoInputLine */    };AddStepForm(PackManNameSlip_v74_0, extrasNameInput);StepDeclare(PackManNameSlip, extrasNameInput, 'extrasNameInput);constant |layout_PackManNameSlip.t| := PackManNameSlip;// End of file PackManNameSlip.t// Beginning of file itemRemoveSlip.t_v179_0 :=    {viewBounds: {left: 0, top: 8, right: 284, bottom: 224},     viewJustify: 80,     tgtArray: nil,     tgtItem: nil,     tgtIndex: nil,     tgtLLName: nil     ,     _proto: @179 /* protoFloater */    };theMsg :=    {text: "Error -666",     viewBounds: {left: 11, top: 14, right: 275, bottom: 164},     viewFormat: 131664,     viewFont: ROM_fontSystem9,     viewJustify: 0,     myBaseString:       "The ^0 associated with the ^1 \"^2\" ^3 is not currently installed. \n\nIf this ^0 is on a storage card which is not" &&       "currently inserted, you should probably skip this ^1. If you have deleted this ^0, you may want to remove this ^1." &&       "If you have reinstalled this ^0 or upgraded to a newer version, you can reassign this ^1 to link to the newer ^0 by" &&       "using the Reassign button. If you want to remove all invalid links without being prompted for each one, tap Remove All."     ,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local targetType, itemType, itemName, LLName;       	       	local theItem := tgtItem;       	       	if theItem.cmdItem then       		begin       			itemType := "shortcut";       			LLName := "(Letter Launcher shortcut \"" & tgtItem.Name & "\")";       			theItem := theItem.cmdItem;       		end       	else       		begin       			LLName := "";       			itemType := "menu item";       		end;       	        	if theItem.type = 'script then       		targetType := "script"       	else       		targetType := "package";       		       	itemName := theItem.text;       	       	self.text := ParamStr(myBaseString, [targetType, itemType, itemName, LLName]);       		       	       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(_v179_0, theMsg);_v179_0_v74_0 :=    {viewBounds: {left: 6, top: 169, right: 294, bottom: 193},     viewFlags: 1,     viewFormat: 1,     viewClass: 74 /* clView */    };AddStepForm(_v179_0, _v179_0_v74_0);_v179_0_v74_0_v226_0 :=    {     buttonClickScript:       func()       begin       	GetRoot().(kAppSymbol).validationNumSkipped := GetRoot().(kAppSymbol).validationNumSkipped +1;       	:Parent():Parent():close();       end,     text: "Skip",     viewBounds: {left: 2, top: 5, right: 62, bottom: 18},     _proto: @226 /* protoTextButton */    };AddStepForm(_v179_0_v74_0, _v179_0_v74_0_v226_0);_v179_0_v74_0_v386_0 :=    {text: "Reassign",     popup:       [       		"Honk",       		"Donk"       ],     viewBounds: {left: 10, top: 5, right: 70, bottom: 18},     viewFlags: 515,     pickActionScript:       func(itemSelected)       begin       	       	local theItem := tgtItem;       	if theItem.cmdItem then theItem := theItem.cmdItem;  //in case of LL cmd       	       	theItem.data := popup[itemSelected].data;       	       	local theEntry := ResolveENtryAlias(theItem.data);       	       	if debugOn then       		begin       			Print("Reassign is printing theEntry:");       			Print(theEntry);       		end;       		       	if theItem.type = 'script then       		begin       			theItem.text := Clone(theEntry.name);       		end       	else       		begin       			theItem.text := Clone(theEntry.text);       		end;       			       	GetRoot().(kAppSymbol).validationNumReassigned := GetRoot().(kAppSymbol).validationNumReassigned + 1;       	:parent():Parent():Close();       	popup := NIL;       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	popup := NIL;       	inherited:?PickCancelledScript();		// this method is defined internally       end,     buttonClickScript:       func()       begin       	local theItem := tgtItem;       	if theItem.cmdItem then theItem := theItem.cmdItem; //for letter launcher cmds       	if theItem.type = 'script then       		begin       			popup := :GetScriptList();       		end       	else       		begin       			popup := :GetSortedPkgList();       		end;       		       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(_v179_0_v74_0, _v179_0_v74_0_v386_0);_v179_0_v74_0_v226_0 :=    {     buttonClickScript:       func()       begin       	GetRoot().(kAppSymbol).validationNumRemoved := GetRoot().(kAppSymbol).validationNumRemoved + 1;       	ArrayRemoveCount(tgtArray, tgtIndex, 1);       		:Parent():Parent():Close();       end,     text: "Remove",     viewBounds: {left: 142, top: 5, right: 202, bottom: 18},     _proto: @226 /* protoTextButton */    };AddStepForm(_v179_0_v74_0, _v179_0_v74_0_v226_0);_v179_0_v74_0_v226_0 :=    {     buttonClickScript:       func()       begin       	:Sysbeep();       	if ModalConfirm("Remove All will automatically remove all references to packages or scripts which aren't currently installed," &&       		"including those which are stored on cards that are not currently" &&       		"inserted. Are you sure this is what you want to do?", ["Remove All", "Cancel"]) = 0 then       			begin       				GetRoot().(kAppSymbol).validationRemAll := TRUE;  //set flag to autoremove all       				GetRoot().(kAppSymbol).validationNumRemoved := GetRoot().(kAppSymbol).validationNumRemoved + 1;       				ArrayRemoveCount(tgtArray, tgtIndex, 1);       				:Parent():Parent():Close();       			end;       end,     text: "Remove All",     viewBounds: {left: 212, top: 5, right: 272, bottom: 18},     _proto: @226 /* protoTextButton */    };AddStepForm(_v179_0_v74_0, _v179_0_v74_0_v226_0);abort :=    {     buttonClickScript:       func()       begin       	GetRoot().(kAppSymbol).abortValidation := TRUE;  //flag to abort        	:Parent():Close();              end,     text: "Stop Validation",     viewBounds: {left: 153, top: 195, right: 277, bottom: 208},     _proto: @226 /* protoTextButton */    };AddStepForm(_v179_0, abort);constant |layout_itemRemoveSlip.t| := _v179_0;// End of file itemRemoveSlip.t// Beginning of file validator.tvalidator :=    {viewBounds: {left: 0, top: 0, right: 300, bottom: 240},     viewJustify: 80,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	GetRoot():LockScreen(true);       	modalator:Close();       	       	//got to redraw views to prevent crashoroni!       	local panelHolder := GetRoot().(kAppSymbol).Pane2.panelholder;       	if panelHolder.newtMenuPanel.viewCObject then        		panelHolder.newtMenuPanel:RedoFakeMenu();       	if panelHolder.scriptPanel.viewCObject then       		panelHolder.scriptPanel:RefreshList();       	if panelHolder.letterLauncherPanel.viewCObject then       		panelHolder.letterLauncherPanel:RefreshList();                     	inherited:?ViewQuitScript();       end,     StartValidate:       func()       begin       		local a, totalBad, b, c, d, e;  //parts of result message              	GetRoot().(kAppSymbol).validationBadCount := 0;       	GetRoot().(kAppSymbol).validationNumChecked := 0;       	GetRoot().(kAppSymbol).validationNumSkipped := 0;       	GetRoot().(kAppSymbol).validationNumRemoved := 0;       	GetRoot().(kAppSymbol).validationNumReassigned := 0;       	GetRoot().(kAppSymbol).abortValidation := NIL;  //flag to abort        	GetRoot().(kAppSymbol).validationRemAll := NIL;       	:DoValidate(myPrefs.nMenu);       	:DoValidate(myPrefs.LLCmds);       	if GetRoot().(kAppSymbol).abortValidation then       		begin       			SetValue(progTxt, 'text, "Validation aborted.");       			SetValue(cancelBtn, 'text, "Done");       			a := "aborted. Not all items were checked.";       		end       	else       		begin       			SetValue(progTxt, 'text, "Validation completed");       			a := "completed successfully. All items were checked.";       			SetValue(mainBtn, 'text, "Done");       			cancelBtn:Close();       		end;       			       	totalBad := :SinglePlural(GetRoot().(kAppSymbol).validationBadCount, "invalid link", "invalid links", "was", "were");       	b := :SinglePlural(GetRoot().(kAppSymbol).validationNumChecked, "item", "items", "was", "were");       	c := :SinglePlural(GetRoot().(kAppSymbol).validationNumRemoved, "item", "items", "was", "were");       	d := :SinglePlural(GetRoot().(kAppSymbol).validationNumReassigned, "item", "items", "was", "were");       	e := :SinglePlural(GetRoot().(kAppSymbol).validationNumSkipped, "item", "items", "was", "were");       	       	local resultMsg := "Validation was ^0\n" &       		"\n^1 checked." &       		"\n^5 found.\n" &       		"\n^2 removed." &       		"\n^3 reassigned." &       		"\n^4 skipped.";       	       	        	resultMsg := ParamStr(resultMsg, [a,b,c,d,e, totalBad]);       	SetValue(msgTxt, 'text, resultMsg);              end,     DoValidate:       func(theArray)       begin       	foreach index, item in theArray do       		begin       			if debugON then print("validating home boy///");       			if GetRoot().(kAppSymbol).abortValidation then break;       			GetRoot().(kAppSymbol).validationNumChecked := GetRoot().(kAppSymbol).validationNumChecked + 1;       			local cItem;       			if item.cmdItem then  //then its a llcmd. cItem is the actal command item to extract data from , whereas item is what to delete       				cItem := item.cmdItem       			else       				cItem := item;       			if cItem.type = 'pkg or cItem.type = 'script then   //thenn check for and delete item       				begin       					SetValue(progTxt, 'text, "Checking" && cItem.Text && "...");       					RefreshViews();       					if ResolveEntryAlias(cItem.data) = NIL then       						begin       							:PromptForWhatToDo(theArray, item, index, item.Name)  //item.Name will be NIL if not LL cmd       							       						end;												       				end       			else if cItem.type = 'sub then       				begin       					:DoValidate(cItem.data);       				end;       		       		end;       end,     PromptForWhatToDo:       func(theArray, theItem, theIndex, theLLName)       begin       	GetRoot().(kAppSymbol).validationBadCount := GetRoot().(kAppSymbol).validationBadCount + 1;       	if GetRoot().(kAppSymbol).validationRemAll then       		begin       			GetRoot().(kAppSymbol).validationNumRemoved := GetRoot().(kAppSymbol).validationNumRemoved + 1;       			ArrayRemoveCount(theArray, theIndex, 1);       		end       	else       		begin       			PFWTDSlip.tgtArray := theArray;       			PFWTDSlip.tgtItem := theItem;       			PFWTDSlip.tgtIndex := theIndex;       			PFWTDSlip.tgtLLName := theLLName;       			PFWTDSlip:ModalDialog();       		end;       end,     _proto: @179 /* protoFloater */    };validator_v229_0 :=    {title: "Dash Board - Validate Prefs",     viewBounds: {left: -7, top: 1, right: 161, bottom: 17},     _proto: @229 /* protoTitle */    };AddStepForm(validator, validator_v229_0);msgTxt :=    {     text:       "Validating Dash Board's preferences searches through your Newton Menu and Letter Launcher prefs, and finds references to missing packages or scripts" &&       "(which are not currently installed). You can optionally remove these items from your preferences, or reassign them. \n\nPlease note that if a package or script is stored on" &&       "a storage card which is not currently inserted, the package or script will be flagged as missing; you probably don't want to remove these items."     ,     viewBounds: {left: 10, top: 24, right: 290, bottom: 174},     viewFormat: 131664,     viewFont: ROM_fontSystem10,     viewJustify: 0,     _proto: @218 /* protoStaticText */    };AddStepForm(validator, msgTxt);StepDeclare(validator, msgTxt, 'msgTxt);progtxt :=    {text: "Tap Start to begin validation.",     viewBounds: {left: 6, top: 181, right: 294, bottom: 205},     viewFont: ROM_fontSystem10Bold,     viewJustify: 8388614,     _proto: @218 /* protoStaticText */    };AddStepForm(validator, progtxt);StepDeclare(validator, progtxt, 'progtxt);mainBtn :=    {     buttonClickScript:       func()       begin       	if StrEqual(text, "Start") then   //determine the state based on the interface? good or bad idea? hmm....       		begin       			:StartValidate();       		end;       	else       		:Parent():Close();       end,     text: "Start",     viewBounds: {left: 240, top: 219, right: 292, bottom: 232},     _proto: @226 /* protoTextButton */    };AddStepForm(validator, mainBtn);StepDeclare(validator, mainBtn, 'mainBtn);cancelBtn :=    {     buttonClickScript:       func()       begin       	:Parent():Close();       end,     text: "Cancel",     viewBounds: {left: 177, top: 219, right: 229, bottom: 232},     _proto: @226 /* protoTextButton */    };AddStepForm(validator, cancelBtn);StepDeclare(validator, cancelBtn, 'cancelBtn);constant |layout_validator.t| := validator;// End of file validator.t// Beginning of file DBP_MenuItem.protomenuItem :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 13},     viewFlags: 513,     viewFormat: 0,     viewJustify: 9776,     viewClickScript:       func(unit)       begin       	Clicker();       	InkOff(Unit);       	:HiliteUnique(true);       	local dragResult := :DND(unit, :globalbox(), :Parent():globalbox(), nil, [{types: ['DBPMenuItem], view: self, dragRef: myIndex}]);       	       	if dragresult <> 2 then       		:Parent():HandleMenuHit(myIndex);       	true;       	// Return true if click has been completely handled, nil otherwise       end,     text: "Menu Item",     viewSetupChildrenScript:       func()       begin       	SetValue(iconHolder, 'icon, self.icon);       	if self.hasSub then SetValue(subArrow, 'viewFlags, vVisible);       	local textWidth := :LocalBox().right - :LocalBox().left - 38;       	       	if :parent().scrolling then  //then leave room for the scrollers       		begin       			local vB := clone(itemText.viewBounds);       			vB.right := vb.right - 16;       			itemText.viewBounds := Clone(vB);       			vB := Clone(subArrow.viewBounds);       			vB.left := vB.left - 16;       			vb.right := vb.right - 16;       			subArrow.viewBounds := Clone(vB);       			textWidth := textWidth - 18;       		end;       		       	SetValue(itemText, 'text, StyledStrTruncate(self.text, textwidth, ROM_FontSystem10Bold));              	       end,     hasSub: nil,     hasScroll: nil,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 8}]);,     height: 13,     DND:       func(a,b,c,d,e)  //( unit, dragBounds, limitBounds, copy, dragInfo));       begin       	call kDragAndDropLtdFunc with (self,a,b,c,d,e);       end,     ViewDropScript:       func(dropType,dropData,dropPt)       begin       	//PRINT("DROPPED");       	//PRINT(dropType);       	//PRINT(dropData);       	//PRINT(dropPT);       	       	local oldIndex, newIndex;       	oldIndex := dropdata.dropindex;              	       	if dropPt.y > :GlobalBox().top + 7 then  //dropped on top half of item       		begin       			if oldIndex < myIndex then       				newIndex := myIndex       			else       				newIndex := myIndex + 1;       		end       	else       		begin       			if oldIndex < myIndex then       				newIndex := myIndex - 1       			else        				newIndex := myIndex;       			       		end;       			       	       	//PRINT("OLD & NEW INDEX VALS:");       	//PRINT(oldIndex);       	//PRINT(newIndex);       	       	AddDeferredSend(:Parent(), 'AcidDrop, [oldIndex,newIndex]);       	       	//return true or nil       end,     ViewGetDropTypesScript:       func(currentPoint)       begin       	return ['DBPMenuItem];       	//return an array of symbols       end,     ViewGetDropDataScript:       func(dragType,dragRef)       begin       	return {dropindex: myIndex};       	//return a frame containing the actual data to be dropped       end,     ViewDropMoveScript:       func(dragRef,offset,lastDragPt,copy)       begin       	return true;       	//return true or nil       end,     ViewDropRemoveScript:       func(dragRef)       begin       	:Hide();       	return true;       	//return true or nil       end,     ViewDropApproveScript:       func(destView)       begin       	if not destView then        		return NIL;       	else       		return TRUE;       	//return true or nil       end,     viewClass: 74 /* clView */    };iconHolder :=    {     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 8}]);,     viewBounds: {left: 3, top: 0, right: 19, bottom: 0},     viewFlags: 1,     viewFormat: nil,     viewJustify: 198,     viewTransferMode: 8,     viewClass: 76 /* clPictureView */    };AddStepForm(menuItem, iconHolder);StepDeclare(menuItem, iconHolder, 'iconHolder);subArrow :=    {     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 131}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 131}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     viewBounds: {left: -16, top: 0, right: -3, bottom: 0},     viewFlags: 0,     viewFormat: nil,     viewJustify: 230,     viewTransferMode: 8,     viewClass: 76 /* clPictureView */    };AddStepForm(menuItem, subArrow);StepDeclare(menuItem, subArrow, 'subArrow);itemText :=    {viewBounds: {left: 24, top: 0, right: 0, bottom: 0},     viewFont: ROM_fontSystem10Bold,     viewJustify: 8388852,     _proto: @218 /* protoStaticText */    };AddStepForm(menuItem, itemText);StepDeclare(menuItem, itemText, 'itemText);constant |layout_DBP_MenuItem.proto| := menuItem;// End of file DBP_MenuItem.proto// Beginning of file DBP_MenuItemDisabled.protomenuItem :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 13},     viewFlags: 513,     viewFormat: 0,     viewJustify: 9776,     viewClickScript:       func(unit)       begin       	Clicker();       	InkOff(Unit);       	:HiliteUnique(true);       	local dragResult := :DND(unit, :globalbox(), :Parent():globalbox(), nil, [{types: ['DBPMenuItem], view: self, dragRef: myIndex}]);       	       	if dragresult <> 2 then       		:Parent():HandleMenuHit(myIndex);       	true;       	// Return true if click has been completely handled, nil otherwise       end,     text: "Menu Item",     DB_Blink:       func()       begin       	:Hilite(nil);       	RefreshViews();       	sleep(5);       	:Hilite(true);       	refreshviews();       	sleep(5);       	:Hilite(nil);       	refreshviews();       	sleep(5);       	:hilite(true);       	refreshviews();       	sleep(5);       	:Hilite(nil);              end,     viewSetupChildrenScript:       func()       begin       	SetValue(iconHolder, 'icon, self.icon);       	SetValue(itemText, 'text, self.text);       	if self.hasSub then SetValue(subArrow, 'viewFlags, vVisible);       end,     hasSub: nil,     hasScroll: nil,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 8}]);,     height: 13,     ViewDropMoveScript:       func(dragRef,offset,lastDragPt,copy)       begin       	return true;       	//return true or nil       end,     ViewDropRemoveScript:       func(dragRef)       begin       	:Hide();       	return true;       	//return true or nil       end,     ViewDropScript:       func(dropType,dropData,dropPt)       begin       	if debugOn then       		begin       			PRINT("DROPPED");       			PRINT(dropType);       			PRINT(dropData);       			PRINT(dropPT);       		end;       	       	local oldIndex, newIndex;       	oldIndex := dropdata.dropindex;              	       	if dropPt.y > :GlobalBox().top + 7 then  //dropped on top half of item       		begin       			if oldIndex < myIndex then       				newIndex := myIndex       			else       				newIndex := myIndex + 1;       		end       	else       		begin       			if oldIndex < myIndex then       				newIndex := myIndex - 1       			else        				newIndex := myIndex;       			       		end;       			       	if debugOn then       		begin       			PRINT("OLD & NEW INDEX VALS:");       			PRINT(oldIndex);       			PRINT(newIndex);       		end;       	       	AddDeferredSend(:Parent(), 'AcidDrop, [oldIndex,newIndex]);       	       	//return true or nil       end,     ViewGetDropDataScript:       func(dragType,dragRef)       begin       	return {dropindex: myIndex};       	//return a frame containing the actual data to be dropped       end,     ViewGetDropTypesScript:       func(currentPoint)       begin       	return ['DBPMenuItem];       	//return an array of symbols       end,     DND:       func(a,b,c,d,e)  //( unit, dragBounds, limitBounds, copy, dragInfo));       begin       	call kDragAndDropLtdFunc with (self,a,b,c,d,e);       end,     ViewDropApproveScript:       func(destView)       begin       	if not destView then        		return NIL;       	else       		return TRUE;       	//return true or nil       end,     viewClass: 74 /* clView */    };iconHolder :=    {icon: nil,     viewBounds: {left: 3, top: 0, right: 19, bottom: 0},     viewFlags: 1,     viewFormat: nil,     viewJustify: 198,     viewTransferMode: 8,     viewClass: 76 /* clPictureView */    };AddStepForm(menuItem, iconHolder);StepDeclare(menuItem, iconHolder, 'iconHolder);subArrow :=    {     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 131}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 131}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     viewBounds: {left: -16, top: 0, right: -3, bottom: 0},     viewFlags: 0,     viewFormat: nil,     viewJustify: 230,     viewTransferMode: 8,     viewClass: 76 /* clPictureView */    };AddStepForm(menuItem, subArrow);StepDeclare(menuItem, subArrow, 'subArrow);itemText :=    {viewBounds: {left: 24, top: 0, right: 0, bottom: 0},     viewFont: {family: 'espy, face: kFaceBold, size: 10, color: kRGB_Gray9},     viewJustify: 8388852,     _proto: @218 /* protoStaticText */    };AddStepForm(menuItem, itemText);StepDeclare(menuItem, itemText, 'itemText);constant |layout_DBP_MenuItemDisabled.proto| := menuItem;// End of file DBP_MenuItemDisabled.proto// Beginning of file ltrCmdItem.protoLLCmdItem :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 13},     viewFlags: 513,     viewFormat: 0,     viewJustify: 9776,     myLtr: "",     myTitle: "",     myIndex: nil,     viewClickScript:       func(unit)       begin       	Clicker();       	:HiliteUnique(true);       	:DoEdit(myIndex);	       	// Return true if click has been completely handled, nil otherwise       end,     selected: nil,     DoSelect:       func(theBool)       begin	       	self.selected := theBool;       	:RedoChildren();	       end,     viewClass: 74 /* clView */    };LLCmdItem_v204_0 :=    {indent: 0,     text: "",     viewBounds: {left: 2, top: 0, right: 16, bottom: 0},     viewJustify: 197,     viewSetupFormScript:       func()       begin       	if selected then viewValue := true;       	inherited:?viewSetupFormScript();       end,     valueChanged:       func()       begin       	if viewValue then        		selected := true       	else       		selected := NIL;       	:SelMade();       end,     _proto: @204 /* protoRCheckBox */    };AddStepForm(LLCmdItem, LLCmdItem_v204_0);LLCmdItem_v76_0 :=    {icon: nil,     viewBounds: {left: 16, top: 0, right: 30, bottom: 0},     viewFlags: 1,     viewFormat: nil,     viewJustify: 198,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.icon := GetRoot().|DashBoard:FiveSpeed|.(myIcon);       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(LLCmdItem, LLCmdItem_v76_0);ltr :=    {text: "",     viewBounds: {left: 36, top: 0, right: 63, bottom: 0},     viewJustify: 8388800,     viewFont: ROM_fontSystem10Bold,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := myLtr;       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(LLCmdItem, ltr);cmdName :=    {text: " ",     viewBounds: {left: 64, top: 0, right: 0, bottom: 0},     viewJustify: 8388848,     viewFont: ROM_fontSystem10,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := StyledStrTruncate(Clone(myTitle), nameWidth, ROM_fontSystem10);       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(LLCmdItem, cmdName);constant |layout_ltrCmdItem.proto| := LLCmdItem;// End of file ltrCmdItem.proto// Beginning of file scriptItem.protosItem :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 13},     viewFlags: 513,     viewFormat: 0,     viewJustify: 9776,     myTitle: "",     viewClickScript:       func(unit)       begin       	Clicker();       	:HiliteUnique(true);       	:EditScript(myAlias);       	       	// Return true if click has been completely handled, nil otherwise       end,     myAlias: nil,     selected: nil,     storeText: "Internal",     DoSelect:       func(theBool)       begin	       	self.selected := theBool;       	:RedoChildren();	       end,     viewClass: 74 /* clView */    };sItem_v204_0 :=    {indent: 0,     text: "",     viewBounds: {left: 2, top: 0, right: 16, bottom: 0},     viewJustify: 197,     valueChanged:       func()       begin       	if viewValue then        		selected := true       	else       		selected := NIL;       	:SelMade();       end,     viewSetupFormScript:       func()       begin       		if selected then viewValue := true;       		inherited:?viewSetupFormScript();       end,     _proto: @204 /* protoRCheckBox */    };AddStepForm(sItem, sItem_v204_0);sItem_v76_0 :=    {     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 128}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00EA\u0", resource: })             ,             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     viewBounds: {left: 17, top: 0, right: 30, bottom: 13},     viewFlags: 1,     viewFormat: nil,     viewClass: 76 /* clPictureView */    };AddStepForm(sItem, sItem_v76_0);sItem_v218_0 :=    {text: " ",     viewBounds: {left: 34, top: 0, right: -36, bottom: 0},     viewJustify: 8388848     ,     viewFont: ROM_fontSystem10,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := StyledStrTruncate(myTitle, nameWidth, ROM_FontSystem10);       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(sItem, sItem_v218_0);sItem_v218_0 :=    {text: "",     viewBounds: {left: -33, top: 0, right: 0, bottom: 0},     viewJustify: 8388840,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := StyledStrTruncate(storeText, 32, rom_fontsystem9);       	inherited:?ViewSetupFormScript();       end,     viewFont: ROM_fontSystem9,     _proto: @218 /* protoStaticText */    };AddStepForm(sItem, sItem_v218_0);constant |layout_scriptItem.proto| := sItem;// End of file scriptItem.proto// Beginning of file specialKey.proto_v218_0 :=    {text: ":=",     viewBounds: {left: 6, top: 0, right: 20, bottom: 14},     viewJustify: 8406022,     viewFormat: 33555025,     viewFlags: 515,     viewClickScript:       func(unit)       begin       	//PlayS       	if :TrackHilite(unit) then       		:InsertText(self.text, self.backSpaces, self.addSpace); //the text, and how many spaces to backup after       	       	:hilite(nil);       	// Return true if click has been completely handled, nil otherwise       end,     backSpaces: 0,     addSpace: nil,     _proto: @218 /* protoStaticText */    };constant |layout_specialKey.proto| := _v218_0;// End of file specialKey.proto// Beginning of file LLedit.tshortcutEdit :=    {viewBounds: {left: 0, top: 0, right: 300, bottom: 300},     viewJustify: 80,     DoHelp:       func(theMsg)       begin       	SetValue(helpText, 'text, theMsg);       end,     myData:       //should be overridden when view is created       {       	cmdItem: NIL,            name: NIL,       },     viewFlags: 64,     UpdateData:       func()       begin       	local s1, s2;       	       	if (myData.cmdItem <> NIL) and (myData.Name <> NIL) then       		begin       			s1 := "Writing \"" & myData.name & "\" in the Letter Launcher box ";       			if (myData.cmdItem.type = 'romapp) or (myData.cmdItem.type = 'pkg) then       				s2 := "will launch the \"" & myData.cmdItem.text & "\" program."       			else if myData.cmdItem.type = 'cmd then       				s2 := "will execute the Special Item \"" & myData.cmdItem.text & "\" (Special Items are convenience features which are built into Dash Board).";       			else       				s2 := "will execute the \""  & myData.cmdItem.text & "\" user script.";	       			SetValue(helpText, 'text, s1 & s2);       		end       	else if (myData.cmdItem = NIL) and (myData.Name <> NIL) then       		begin       			s1 := "The shortcut text is set to \"" & myData.name & "\". Now, please use the buttons below to select the action that should occur when you write this text in the Letter Launcher.";       			SetValue(helpText, 'text, s1);       		end       	else if (myData.cmdItem <> NIL) and (myData.Name = NIL) then       		begin       			if (myData.cmdItem.type = 'romapp) or (myData.cmdItem.type = 'pkg) then       				s2 := "This shortcut will launch the \"" & myData.cmdItem.text & "\" program. Now, please enter the letter (or letters) you want to associate with this shortcut."       			else if myData.cmdItem.type = 'cmd then       				s2 := "This shortcut will execute the Special Item \"" & myData.cmdItem.text & "\" (Special Items are convenience features which are built into Dash Board). Now, please enter the letter (or letters) you want to associate with this shortcut.";       			else       				s2 := "This shortcut will execute the \""  & myData.cmdItem.text & "\" user script. Now, please enter the letter (or letters) you want to associate with this shortcut.";	       			SetValue(helpText, 'text, s2);       		end       	else       		begin       			SetValue(helpText, 'text, "To create a new Letter Launcher shortcut, enter a letter (or letters) and then choose a corresponding action, using the buttons below.");       		end;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.myData := Clone(self.myData);       	inherited:?ViewSetupFormScript();       end,     editMode: nil,     AddShortcut:       func(theData)       begin       end,     editIndex: nil,     viewSetupDoneScript:       func()       begin       	:UpdateData();       	modalator:open();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	//CHANGED 990813 (ad io hella didnt need to! uhhg!       	local cleanFunc := func()       		begin       			tgt := if self.refreshee then Clone(self.refreshee) else NIL;       			if tgt and tgt.viewCObject then tgt:RedoChildren();       		end;       			       	if self.refreshee then AddDeferredCall(cleanFunc, NIL);       	modalator:close();       	:DeathPenalty();       	inherited:?ViewQuitScript();       end,     CaretHack:       func()       begin       	theText:SetHilite(0,999,nil);              end,     deathRow:       '[       	editIndex,       	editMode,       	myData       ],     _proto: @180 /* protoFloatNGo */    };shortcutEdit_v229_0 :=    {title: "Letter Launcher Shortcut",     viewBounds: {left: 8, top: -8, right: 120, bottom: 8},     _proto: @229 /* protoTitle */    };AddStepForm(shortcutEdit, shortcutEdit_v229_0);helpText :=    {text: "help for Letter Launcher Shortcut editor",     viewBounds: {left: 0, top: 27, right: 288, bottom: 75},     viewFont: simpleFont9,     viewFormat: 197200,     viewJustify: 16,     _proto: @218 /* protoStaticText */    };AddStepForm(shortcutEdit, helpText);StepDeclare(shortcutEdit, helpText, 'helpText);shortcutEdit_v218_0 :=    {text: "Shortcut:",     viewBounds: {left: -2, top: 83, right: 86, bottom: 95},     viewJustify: 8388624,     _proto: @218 /* protoStaticText */    };AddStepForm(shortcutEdit, shortcutEdit_v218_0);theText :=    {viewBounds: {left: 0, top: 96, right: 88, bottom: 128},     viewLineSpacing: 30,     viewFormat: 12880,     viewJustify: 16777232,     viewChangedScript:       func(slot, view)       begin       	       	local myText := Clone(self.text);       	local origLength := StrLen(myText);       	       	myText := StringFilter(myText, " \t\n", 'rejectAll);       	       	if origLength > StrLen(myText) then        		begin       			:SysBeep();       			AddDeferredCall(func() setValue(self, 'text, myText), NIL);       		end;       	       	if STREqual(myText, "") then       		:Parent().myData.name := NIL       	else       		:Parent().myData.name := myText;       	:Parent():UpdateData();       	nil;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if editMode then self.text := myData.name;       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	AddDeferredSend(self, 'SetHilite, [0,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     _proto: @185 /* protoInputLine */    };AddStepForm(shortcutEdit, theText);StepDeclare(shortcutEdit, theText, 'theText);kbd :=    {viewBounds: {left: 0, top: -168, right: 225, bottom: -87},     viewJustify: 144,     _proto: @375 /* protoAlphaKeyboard */    };AddStepForm(shortcutEdit, kbd);StepDeclare(shortcutEdit, kbd, 'kbd);shortcutEdit_v218_0 :=    {text: "Choose what this shortcut should do:",     viewBounds: {left: 1, top: 220, right: 289, bottom: 236},     _proto: @218 /* protoStaticText */    };AddStepForm(shortcutEdit, shortcutEdit_v218_0);shortcutEdit_v386_0 :=    {text: "",     popup:       [              ],     viewBounds: {left: -286, top: 238, right: -162, bottom: 253},     viewFlags: 515,     buttonClickScript:       func()       begin       	popup := GetRoot().(kAppSymbol):GetSortedPkgList();       			       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(itemSelected)       begin       	local theIcon := 'iPackage;       	local chosenEntry := ResolveEntryAlias(popup[itemSelected].data);       	       	if chosenEntry then       			begin       				if chosenEntry.class = 'frozenEntry then        					theIcon := 'iSnowflake        				else if (chosenEntry.class = 'bookEntry) or (chosenEntry.class = 'helpBookENtry) then        					theIcon := 'iBook;       			end;       			       	:Parent().myData.cmdItem := {type: 'pkg, data: popup[itemSelected].data, text: popup[itemSelected].item, icon: theIcon};       	:Parent():updateData();       	popup := nil;       	:Parent():CaretHack();              	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	popup:=nil;       	:Parent():CaretHack();       	inherited:?PickCancelledScript();		// this method is defined internally       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(shortcutEdit, shortcutEdit_v386_0);shortcutEdit_v386_0_v0_0 :=    {text: "Launch Package", icon: 'iPackage, _proto: _v74_0};AddStepForm(shortcutEdit_v386_0, shortcutEdit_v386_0_v0_0);shortcutEdit_v386_0 :=    {text: "",     popup: [],     viewBounds: {left: -124, top: 260, right: 0, bottom: 275},     viewFlags: 515,     buttonClickScript:       func()       begin       	       	popup := GetRoot().(kAppSYmbol):GetSpecialsList(nil);       	       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(itemSelected)       begin              	:Parent().myData.cmdItem := popup[itemSelected].data;       	:Parent():updateData();       	popup := nil;       	:Parent():CaretHack();              	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	popup := nil;       	inherited:?PickCancelledScript();		// this method is defined internally       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(shortcutEdit, shortcutEdit_v386_0);shortcutEdit_v386_0_v0_0 :=    {text: "Special Item", icon: 'iSpecials, _proto: _v74_0};AddStepForm(shortcutEdit_v386_0, shortcutEdit_v386_0_v0_0);shortcutEdit_v386_0 :=    {text: "",     popup: [],     viewBounds: {left: -124, top: 282, right: 0, bottom: 297},     viewFlags: 515,     buttonClickScript:       func()       begin       	       	local sList := GetRoot().(kAppSYmbol):GetScriptList();       	       	if sList then       		popup := sList;       	else       		popup := [ {item: "(No Scripts Available)", pickable: NIL} ];       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(itemSelected)       begin              	:Parent().myData.cmdItem := {type: 'script, data: popup[itemSelected].data, text: popup[itemSelected].item, icon: 'iScript};       	:Parent():updateData();       	popup := nil;       	:Parent():CaretHack();              	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	popup := nil;       	inherited:?PickCancelledScript();		// this method is defined internally       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(shortcutEdit, shortcutEdit_v386_0);shortcutEdit_v386_0_v0_0 := {text: "Run Script", icon: 'iScript, _proto: _v74_0}    ;AddStepForm(shortcutEdit_v386_0, shortcutEdit_v386_0_v0_0);saveBtn :=    {     buttonClickScript:       func()       begin       	if myData.name = NIL or myData.cmdItem = NIL then       		begin       			:SysBeep();       			if not myData.name then       				:DoHelp("You must specify the letter(s) you want to trigger this shortcut before you can save. Enter the letter(s) in the Shortcut box below.");       			if not myData.cmdItem then       				:DoHelp("Before you can save this shortcut, you must specify an action to happen when this shortcut is executed. Use the buttons below to choose what this shortcut should do.");       			return;       		end;       	       	       	if editMode then       		begin       			UpCase(myData.name);       			local cmdExists := LSearch(GetRoot().(kAppSymbol).myPrefs.LLCmds, myData.Name, 0, '|str=|, 'Name);       			if cmdExists and (cmdExists <> editIndex) then       				begin       					local oldSCName := GetRoot().(kAppSymbol).myPrefs.LLCmds[cmdExists].cmdItem.text;       					if modalConfirm("Warning: the text \"" & DeepClone(myData.Name) & "\" is already assigned to another shortcut (\"" & oldSCName & "\"). Saving the current shortcut will replace the old one.       					 Are you sure you want to continue?", 'yesNo) then       					 	begin       					 		UpCase(myData.Name);       					 		GetRoot().(kAppSymbol).myPrefs.LLCmds[cmdExists] := DeepClone(myData);       					 		ArrayRemoveCOunt(GetRoot().(kAppSymbol).myPrefs.LLCmds, editIndex, 1);       							:Parent():CLose();       						end;       				end       			else       				begin       					GetRoot().(kAppSymbol).myPrefs.LLCmds[editIndex] := DeepClone(myData);       					if resultView then SetValue(resultView, 'text, "The shortcut \"" & DeepClone(myData.Name) & "\" was modified successfully.");       					:Parent():CLose();       			end;       		end       	else       		begin       			local cmdExists := LSearch(GetRoot().(kAppSymbol).myPrefs.LLCmds, myData.Name, 0, '|str=|, 'Name);       			       			if cmdExists then       				begin       					local oldSCName := GetRoot().(kAppSymbol).myPrefs.LLCmds[cmdExists].cmdItem.text;       					if modalConfirm("Warning: the text \"" & DeepClone(myData.Name) & "\" is already assigned to another shortcut (\"" & oldSCName & "\"). Saving the current shortcut will replace the old one.       					 Are you sure you want to continue?", 'yesNo) then       					 	begin       					 		UpCase(myData.Name);       					 		GetRoot().(kAppSymbol).myPrefs.LLCmds[cmdExists] := DeepClone(myData);       							:Parent():CLose();       						end;       				end       			else       				begin       					UpCase(myData.Name);       					AddArraySlot(GetRoot().(kAppSymbol).myPrefs.LLCmds, DeepClone(myData));       					if resultView then SetValue(resultView, 'text, "The shortcut \"" & DeepClone(myData.Name) & "\" was added successfully.");       					:Parent():CLose();       				end;       		end;       				       	       end,     text: "Add",     viewBounds: {left: 247, top: 284, right: 297, bottom: 297},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if editMode then self.text := "Save";       	inherited:?ViewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(shortcutEdit, saveBtn);cancelBtn :=    {     buttonClickScript:       func()       begin       	kbd:Close();  //hack to avoid redraw glitch!       	       	if editMode then       		begin       			if resultView then SetValue(resultView, 'text, "The shortcut \"" & Clone(myData.Name) & "\" was not modified because the operation was cancelled.");       		end       	else       		begin       			if resultView then SetValue(resultView, 'text, "The shortcut was not added because the operation was cancelled.");       		end;       	:Parent():CLose();              end,     text: "Cancel",     viewBounds: {left: 188, top: 284, right: 238, bottom: 297},     _proto: @226 /* protoTextButton */    };AddStepForm(shortcutEdit, cancelBtn);constant |layout_LLedit.t| := shortcutEdit;// End of file LLedit.t// Beginning of file subOpts.tsubOpts :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 512,     viewFormat: 0,     viewJustify: 240,     viewSetupChildrenScript:       func()       begin       	newName.text := myItem.text;       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	if myCaller then       		begin       			 myCaller:RedoFakeMenu();       			 myCaller:ShowItem(myIndex);       			 if newMode then       			 	myCaller:DoHelp("Added submenu \"" & myItem.text & "\" to the Newton Menu.");       			 else       			 	myCaller:DoHelp("The name of the submenu was changed to \"" & myItem.text & "\".");       		end;       	:DeathPenalty();       	       	inherited:?ViewQuitScript();       end,     newMode: nil,     deathRow:       '[       	mycaller,       	myItem,       	newMode,       	myIndex       ],     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	myCaller:DoHelp("Enter the name for the new submenu in the slip.");       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };subOpts_v180_0 :=    {viewBounds: {left: 0, top: 0, right: 280, bottom: 150},     viewJustify: 80,     viewFlags: 65,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	myItem.text := Clone(newName.text);       	AddDeferredSend(:Parent(), 'Close, nil);       	inherited:?ViewQuitScript();       end,     _proto: @180 /* protoFloatNGo */    };AddStepForm(subOpts, subOpts_v180_0);newName :=    {viewBounds: {left: 14, top: 27, right: 266, bottom: 58},     viewLineSpacing: 29,     viewFormat: 12880,     viewSetupDoneScript:       func()       begin       	AddDeferredSend(self, 'SetHilite, [0,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     _proto: @185 /* protoInputLine */    };AddStepForm(subOpts_v180_0, newName);StepDeclare(subOpts, newName, 'newName);subOpts_v180_0_v229_0 :=    {title: "Submenu Name",     viewBounds: {left: -20, top: -22, right: 52, bottom: 10},     _proto: @229 /* protoTitle */    };AddStepForm(subOpts_v180_0, subOpts_v180_0_v229_0);subOpts_v180_0_v375_0 :=    {viewBounds: {left: 26, top: -86, right: 251, bottom: -5},     _proto: @375 /* protoAlphaKeyboard */    };AddStepForm(subOpts_v180_0, subOpts_v180_0_v375_0);constant |layout_subOpts.t| := subOpts;// End of file subOpts.t// Beginning of file scriptInfoEditor.protoscriptInfoEditor :=    {viewBounds: {left: 8, top: 8, right: -8, bottom: -8},     viewJustify: 240,     sName: nil,     sText: nil,     sTextHolder: nil,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	editee.info := NotesText(sText:ChildViewFrames());       	editee.id := Intern(sName.text);              	inherited:?ViewQuitScript();       end,     viewFlags: 576,     skroller: nil,     scrollOrigin: 0,     deathRow:       '[       	sText,       	sTextHolder,       	sName,       	scrollOrigin,       	skroller,       ],     _proto: @180 /* protoFloatNGo */    };scriptInfoEditor_v229_0 :=    {title: "Dash Board Script Info",     viewBounds: {left: -4, top: -1, right: 148, bottom: 15},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.title := Clone(editee.name) && "Info";       	inherited:?ViewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(scriptInfoEditor, scriptInfoEditor_v229_0);sTitle :=    {viewBounds: {left: 6, top: 20, right: -6, bottom: 60},     viewFlags: 1,     viewFormat: 592,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(scriptInfoEditor, sTitle);StepDeclare(scriptInfoEditor, sTitle, 'sTitle);sTitle_v218_0 :=    {text: " Script Unique ID:",     viewBounds: {left: 0, top: 0, right: 0, bottom: 12},     viewJustify: 8388664,     viewClickScript:       func(unit)       begin       	true;       	// Return true if click has been completely handled, nil otherwise       end,     viewFormat: 14,     viewFillPattern: kRGB_Gray6,     _proto: @218 /* protoStaticText */    };AddStepForm(sTitle, sTitle_v218_0);sTitle_v185_0 :=    {viewBounds: {left: 2, top: 1, right: -2, bottom: -1},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := SPrintObject(editee.id);       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	sName := self;       	AddDeferredSend(self, 'SetHilite, [999,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     viewLineSpacing: 37,     viewJustify: 8388848,     viewlinepattern: kRGB_Gray7,     _proto: @185 /* protoInputLine */    };AddStepForm(sTitle, sTitle_v185_0);sBody :=    {viewBounds: {left: 6, top: 67, right: -6, bottom: 303},     viewFlags: 33,     viewFormat: 592,     viewJustify: 48,     viewSetupChildrenScript:       func()       begin       	theText.viewBounds := InsetRect(:LocalBox(),2,2);  //set the edit view's bounds to inset of sBody's bounds       	theText.viewBounds.right := theText.viewBounds.right - 18;       	theText.viewBounds.top := theText.viewBounds.top + 12;       end,     viewSetupDoneScript:       func()       begin       	sTextHolder := self;       end,     lBounds: SetBounds(6,67,-6,200),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(scriptInfoEditor, sBody);theText :=    {viewBounds: {left: 2, top: 14, right: 160, bottom: 120},     viewFlags: 191009,     viewFont: simpleFont9,     viewFormat: 57344,     viewLineSpacing: 12,     textFlags: vFixedTextStyle,     viewJustify: 0,     viewSetupDoneScript:       func()       begin       	sText := self;       	changesMade := NIL;       		       	//moved from viewSetupChildren script       	self.viewChildren := [];       	AddArraySlot(self.viewChildren,        		{       			//viewClass: clParagraphView,        			viewStationery: 'para,        			tabs: kidsTabs,       			text: editee.info,        			viewBounds: InsetRect(self.viewBounds, -2, -2),       			viewFont: kidsViewFont,         			textFlags: kidsTextFlags,       			viewFlags: kidsViewFlags        		});       		:RedoChildren();              end,     viewlinepattern: kRGB_Gray7,     viewChangedScript:              func(slot, view)  //ensure that view scrolls up as user enters text down        begin              if debugON then print("viewChangeScript() doing its thing...");              if slot = 'text then       		begin       			local firstLine := :pointToCharOffset(0, sText:globalBox().top);       			local lastLine := :pointToCharOffset(0, sText:GlobalBox().bottom);       			       			if lastLine > 0 then        				if getcaretInfo().info.offset >= lastLine then :DoScroll(1, nil);       			       			if firstLine > 0 then       				if GetCaretInfo().info.offset <= firstLine then :DoScroll(-1,nil);       			       			changesMade := true;       		end;       	nil;              inherited:?viewCHangedScript(slot, view);              end,     editAddWordScript:       func(form, bounds)       begin       	if debugOn then PRINT("EDIT ADD WORD SCRIPT!");       	if debugOn then PRINT(form);       	form.viewFont := kidsViewFOnt;       	form.tabs := kidsTabs;       	form.viewFlags := kidsViewFlags;       	form.textFlags := kidsTextFlags;       	form.viewBounds.left := 0; //is this ok? never read only?       	       	return form;       end,     GetTextHeight:       func()       begin       	local theHeight := 0;       	       	foreach i in :ChildViewFrames() do       		theHeight := Max(theHeight, i.viewBounds.bottom);       		       	if debugOn then PRINT("GetTextHeight is returning:" && theHeight);       	       	return theHeight;       end,     kidsTextFlags: vWidthIsParentWidth+vFixedTextStyle,     kidsViewFlags: vVisible+vCalculateBounds+vNoScripts,     kidsTabs: [5,10,15,20,25,30,35,40],     kidsViewFont:       simpleFont9 //LATER set this to pref font       ,     viewSetupChildrenScript: ,     ViewDropScript:       func(dropType,dropData,dropPt)       begin              	if debugOn then        		begin       			print("BYOO DOROPPU SUKURIPUTO");       			print(dropType);       			print(dropData);       			       			print("here goes changing the data attmepts...");       	end;       	       	if dropType <> 'text then       		begin       			:Notify(kNotifyAlert, kAppName, "The Dash Board Script Editor requires plain text data. Other data, such as ink text or graphics, cannot be dropped into the Script Editor.");       			return NIL;       		end       	else       		begin       			dropData.viewFont := kidsViewFont;       			local newBounds := Clone(dropData.viewBounds);       			newBounds := SetBounds( newBounds.left - newBounds.left, newBounds.top, newBounds.right - newBounds.left, newBounds.bottom);       			dropData.viewBounds := newBounds;       		end;              	inherited:?viewDropScript();       	//return true or nil       end,     viewClass: 77 /* clEditView */    };AddStepForm(sBody, theText);StepDeclare(scriptInfoEditor, theText, 'theText);sBody_v218_0 :=    {text: " Script Info Comments:",     viewBounds: {left: 0, top: 0, right: 0, bottom: 12},     viewJustify: 8388664,     viewFormat: 14,     viewFillPattern: kRGB_Gray6,     _proto: @218 /* protoStaticText */    };AddStepForm(sBody, sBody_v218_0);scrollerz :=    {viewBounds: {left: -14, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 592,     viewJustify: 13536,     viewClass: 74 /* clView */    };AddStepForm(scriptInfoEditor, scrollerz);StepDeclare(scriptInfoEditor, scrollerz, 'scrollerz);scrollerz_v198_0 :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 18},     buttonClickScript:       func()       begin       	:DoScroll('top, nil);       end,     viewJustify: 54,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 912}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewFormat: 593,     _proto: @198 /* protoPictureButton */    };AddStepForm(scrollerz, scrollerz_v198_0);scrollerz_v198_0 :=    {viewBounds: {left: 0, top: -18, right: 0, bottom: 0},     buttonClickScript:       func()       begin       	:DoScroll('bottom, nil);       end,     viewJustify: 182,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 151}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewFormat: 593,     _proto: @198 /* protoPictureButton */    };AddStepForm(scrollerz, scrollerz_v198_0);scrollerz_v656_0 :=    {viewBounds: {left: -16, top: 0, right: 2, bottom: 33},     ViewScroll2DScript:       func(direction,extras)       begin       	       	if direction = 'up then       		:Parent():Parent():DoScroll(-1,extras);       	else if direction = 'down then       		:Parent():Parent():DoScroll(1,extras);       	RefreshViews();       		       	Inherited:?ViewScroll2DScript(direction,extras);       end,     viewSetupDoneScript:       func()       begin       	skroller := self;       end,     _proto: @656 /* protoUpDownScroller */    };AddStepForm(scrollerz, scrollerz_v656_0);scriptInfoEditor_v74_0 :=    {viewBounds: {left: 4, top: 309, right: -4, bottom: 396},     viewFlags: 1,     viewFormat: 0,     viewJustify: 48,     lBounds: SetBounds(4,205,-4,292),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(scriptInfoEditor, scriptInfoEditor_v74_0);scriptInfoEditor_v74_0_v375_0 :=    {viewBounds: {left: 0, top: 0, right: 225, bottom: 81},     viewJustify: 16,     _proto: @375 /* protoAlphaKeyboard */    };AddStepForm(scriptInfoEditor_v74_0, scriptInfoEditor_v74_0_v375_0);constant |layout_scriptInfoEditor.proto| := scriptInfoEditor;// End of file scriptInfoEditor.proto// Beginning of file scriptEditor.tscriptEditor :=    {viewBounds: {left: 9, top: 9, right: 311, bottom: 425},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.viewBounds := InsetRect(getappparams().appareabounds, 9,9);       	if not self.editee then        		begin       			local dsText := "//   Replace the dummy code below with your script code.\n//   Your script will be compiled as a function \n//   that takes no parameters, like this:\n//\n//   func() begin /* your code here */ end\n\nModalConfirm(\"This is a script!\", [\"Cool\"]);\n\n";       			self.editee := {name: "Untitled Script", scriptText: CLone(dsText), date: TimeInSeconds(), id: Intern(GetUserConfig('name) & ":" & TimeInSeconds()), info: ""};  //fuck! the CLONE() solved horrid probelm! see NOTE 1       			newMode := true;       		end;       	       	inherited:?ViewSetupFormScript();       end                            /************* NOTES FOR THIS METHOD *********************              NOTE 1: new scripts were not able to be saved corectly until we started cloning scriptText when setting up editee.       I dont really kno why, as the protoInputLine also did self.text:=editee.name, just like we set the text slot of the        clParagraphView to editee.scriptText, but whatever, it works now....                            ************* END NOTES FOR THIS METHOD ******************/,     viewJustify: 0,     newMode: nil,     editee: nil,     presaveScript:       func()       begin       	editee.scriptText := NotesText(sText:ChildViewFrames());       	       	if debugON then PRINT("PRESAVING:\n" & editee.scriptText);       	       	editee.Name := sName.text;       end              //NOTES: why the FUCK does notesText() return fucking text that fucking isn't fucking there??? after deleting text, with standard scrub, NotesText is still       //fucking returning the old text....MAYBE SOLVED: it is because even though you add kids to viewChildren slot, you should be doing NotesText on editVie:ChildViewFrames().       //BUT the docs say to use editView.viewChildren!!!!!       ,     sText: nil,     sName: nil,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	if debugOn then       		begin       			Print("scriptEditor.viewDropScript is executing......honk honk honk");       			local sTicks := Ticks();       		end;       		       	if panelView.viewCObject then        		begin       			panelView:RefreshList();       			panelView:setHelp(resultMsg);       		end;       		       	foreach i in deathRow do       		RemoveSlot(self, i);       	       	if debugOn then        		begin       			local eTicks := Ticks();       			Print("It took" && (eTicks - sTicks) && "ticks......honk honk honk");       		end;       		       	inherited:?ViewQuitScript();       end,     DoScroll:       func(howMuch, extras) //int num lines to scroll, or 'top or 'bottom;       begin       	       		       	local textHeight := sText:GetTextHeight();       	local visHeight := sText:LocalBox().bottom - sText:LocalBox().top;       	local maxBottom := Max(0,textHeight - visHeight + 12);  //added + 12 to fix bugger where it scrolled down to second to last line max              	if IsInteger(howMuch) then       		begin       			howMuch := howMuch * 12;       			scrollOrigin := scrollOrigin + howMuch;       			       			if Max(0,scrollOrigin) = 0 then  //we're all the way at top       				begin       					scrollOrigin := 0;       					if extras then       						begin       							if not extras.stopped then       								begin       									skroller:playStopSound();       									extras.stopped := true;       								end;       						end;       				end       			else if Min(maxBottom, scrollorigin) = maxBottom then  //we're all the way at bottom       				begin       					scrollOrigin := maxBottom;       					if extras then       						begin       							if not extras.stopped then       								begin       									skroller:playStopSound();       									extras.stopped := true;       								end;       						end;       				end;       		end       	else if howMuch = 'top then       		scrollorigin := 0;       	else if howMuch = 'bottom then       		scrollOrigin := maxBottom;       	       	sText:SetOrigin(0,scrollorigin);        	       	AddProcrastinatedSend('|scrUD:DBP:FiveSpeed|, self, 'RefreshArrows, nil, 0);       	       end,     scrollOrigin: 0,     sTextHolder: nil,     RefreshArrows:       func()       begin       	local textHeight := sText:GetTextHeight();       	local visHeight := sTextHolder:LocalBox().bottom - sTextHolder:LocalBox().top;       	local maxBottom := textHeight - visHeight;       	       	if scrollorigin = 0 then       		skroller:SetArrow('up, 'normal)       	else       		skroller:SetArrow('up, 'more);       		       	if scrollorigin >= maxBottom then       		skroller:SetArrow('down,'normal);       	else       		skroller:SetArrow('down,'more);       end,     skroller: nil,     viewSetupDoneScript:       func()       begin       	:RefreshArrows();       end,     changesMade: nil,     resultMsg: "Something happened, but I don't know what it was! I'm bad!",     deathRow:       '[       	editee,       	sText,       	sName,       	sTextHolder,       	resultMsg,       	changesMade,       	scrollOrigin,       	skroller,       	newMode       ],     EditInfo:       func()       begin       	infoEditor:Open();       end,     _proto: @180 /* protoFloatNGo */    };infoEditor := {_proto: scriptInfoEditor};AddStepForm(scriptEditor, infoEditor);StepDeclare(scriptEditor, infoEditor, 'infoEditor);closeHider :=    {viewBounds: {left: -15, top: -15, right: 0, bottom: 0},     viewFlags: 513,     viewFormat: 1,     viewJustify: 160,     viewClass: 74 /* clView */    };AddStepForm(scriptEditor, closeHider);scriptEditor_v229_0 :=    {title: "Dash Board Script Editor",     viewBounds: {left: -16, top: 0, right: 96, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(scriptEditor, scriptEditor_v229_0);sTitle :=    {viewBounds: {left: 6, top: 20, right: -6, bottom: 50},     viewFlags: 1,     viewFormat: 592,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(scriptEditor, sTitle);StepDeclare(scriptEditor, sTitle, 'sTitle);sTitle_v185_0 :=    {viewBounds: {left: 2, top: 1, right: -2, bottom: -1},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.text := editee.name;       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	sName := self;       	AddDeferredSend(self, 'SetHilite, [999,999,nil]);       	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     viewLineSpacing: 27,     viewJustify: 8388848,     viewlinepattern: kRGB_Gray7,     _proto: @185 /* protoInputLine */    };AddStepForm(sTitle, sTitle_v185_0);sBody :=    {viewBounds: {left: 6, top: 57, right: -6, bottom: -112},     viewFlags: 33,     viewFormat: 592,     viewJustify: 240,     viewSetupChildrenScript:       func()       begin       	theText.viewBounds := InsetRect(:LocalBox(),2,2);  //set the edit view's bounds to inset of sBody's bounds       	theText.viewBounds.right := theText.viewBounds.right - 18       end,     viewSetupDoneScript:       func()       begin       	sTextHolder := self;       end,     lBounds: SetBounds(6,57,-6,-91),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(scriptEditor, sBody);theText :=    {viewBounds: {left: 2, top: 2, right: 160, bottom: 120},     viewFlags: 191009,     viewFont: simpleFont9,     viewFormat: 57344,     viewLineSpacing: 12,     textFlags: vFixedTextStyle,     viewJustify: 0,     viewSetupDoneScript:       func()       begin       	sText := self;       	changesMade := NIL;       	       	//moved from viewSetupChildren script       	self.viewChildren := [];       	AddArraySlot(self.viewChildren,        		{       			//viewClass: clParagraphView,        			viewStationery: 'para,        			tabs: kidsTabs,       			text: editee.scriptText,        			viewBounds: InsetRect(self.viewBounds, -2, -2),       			viewFont: kidsViewFont,         			textFlags: kidsTextFlags,       			viewFlags: kidsViewFlags        		});       		:RedoChildren();              end,     viewlinepattern: kRGB_Gray7,     viewChangedScript:              func(slot, view)  //ensure that view scrolls up as user enters text down        begin              if debugON then print("viewChangeScript() doing its thing...");              if slot = 'text then       		begin       			local theCaretInfo := GetCaretInfo();       			if theCaretInfo then       				begin       					local firstLine := :pointToCharOffset(0, sText:globalBox().top);       					local lastLine := :pointToCharOffset(0, sText:GlobalBox().bottom);       					       					if lastLine > 0 then        						if getcaretInfo().info.offset >= lastLine then :DoScroll(1, nil);       					       					if firstLine > 0 then       						if GetCaretInfo().info.offset <= firstLine then :DoScroll(-1,nil);       				end;       			       			changesMade := true;       		end;       	nil;              inherited:?viewCHangedScript(slot, view);              end,     editAddWordScript:       func(form, bounds)       begin       	if debugOn then PRINT("EDIT ADD WORD SCRIPT!");       	if debugOn then PRINT(form);       	form.viewFont := kidsViewFOnt;       	form.tabs := kidsTabs;       	form.viewFlags := kidsViewFlags;       	form.textFlags := kidsTextFlags;       	form.viewBounds.left := 0; //is this ok? never read only?       	       	return form;       end,     GetTextHeight:       func()       begin       	local theHeight := 0;       	       	foreach i in :ChildViewFrames() do       		theHeight := Max(theHeight, i.viewBounds.bottom);       		       	if debugOn then PRINT("GetTextHeight is returning:" && theHeight);       	       	return theHeight;       end,     kidsTextFlags: vWidthIsParentWidth+vFixedTextStyle,     kidsViewFlags: vVisible+vCalculateBounds+vNoScripts,     kidsTabs: [5,10,15,20,25,30,35,40],     kidsViewFont:       simpleFont9 //LATER set this to pref font       ,     ViewDropScript:       func(dropType,dropData,dropPt)       begin              	if debugOn then        		begin       			print("BYOO DOROPPU SUKURIPUTO");       			print(dropType);       			print(dropData);       			       			print("here goes changing the data attmepts...");       	end;       	       	if dropType <> 'text then       		begin       			:Notify(kNotifyAlert, kAppName, "The Dash Board Script Editor requires plain text data. Other data, such as ink text or graphics, cannot be dropped into the Script Editor.");       			return NIL;       		end       	else       		begin       			dropData.viewFont := kidsViewFont;       			local newBounds := Clone(dropData.viewBounds);       			newBounds := SetBounds( newBounds.left - newBounds.left, newBounds.top, newBounds.right - newBounds.left, newBounds.bottom);       			dropData.viewBounds := newBounds;       		end;              	inherited:?viewDropScript();       	//return true or nil       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	kidsViewFont := myPrefs.scriptFont;       	viewLineSpacing := FontHeight(kidsViewFont);       	inherited:?ViewSetupFormScript();       end,     viewClass: 77 /* clEditView */    };AddStepForm(sBody, theText);StepDeclare(scriptEditor, theText, 'theText);scrollerz :=    {viewBounds: {left: -14, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 592,     viewJustify: 13536,     viewClass: 74 /* clView */    };AddStepForm(scriptEditor, scrollerz);StepDeclare(scriptEditor, scrollerz, 'scrollerz);topBtn :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 18},     buttonClickScript:       func()       begin       	:DoScroll('top, nil);       end,     viewJustify: 54,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 912}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewFormat: 593,     _proto: @198 /* protoPictureButton */    };AddStepForm(scrollerz, topBtn);bottomBtn :=    {viewBounds: {left: 0, top: -18, right: 0, bottom: 0},     buttonClickScript:       func()       begin       	:DoScroll('bottom, nil);       end,     viewJustify: 182,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 151}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewFormat: 593,     _proto: @198 /* protoPictureButton */    };AddStepForm(scrollerz, bottomBtn);scrollerz_v656_0 :=    {viewBounds: {left: -16, top: 0, right: 2, bottom: 33},     ViewScroll2DScript:       func(direction,extras)       begin       	       	if direction = 'up then       		:Parent():Parent():DoScroll(-1,extras);       	else if direction = 'down then       		:Parent():Parent():DoScroll(1,extras);       	RefreshViews();       		       	Inherited:?ViewScroll2DScript(direction,extras);       end,     viewSetupDoneScript:       func()       begin       	skroller := self;       end,     _proto: @656 /* protoUpDownScroller */    };AddStepForm(scrollerz, scrollerz_v656_0);sControls :=    {viewBounds: {left: 4, top: -107, right: -4, bottom: -20},     viewFlags: 1,     viewFormat: 1,     viewJustify: 176,     lBounds: SetBounds(4,-87,-4,0),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(scriptEditor, sControls);sControls_v375_0 :=    {viewBounds: {left: 0, top: 0, right: 225, bottom: 81},     viewJustify: 0,     _proto: @375 /* protoAlphaKeyboard */    };AddStepForm(sControls, sControls_v375_0);specialKeys :=    {viewBounds: {left: 232, top: 0, right: 294, bottom: 81},     viewFlags: 1,     viewFormat: 1,     Inserttext:       func(txt, bs, SpaceOrNOt)       begin       	InsertItemsAtCaret({insertItems: txt, addSpace: spaceOrNOt});       end,     viewClass: 74 /* clView */    };AddStepForm(sControls, specialKeys);specialKeys_v0_0 :=    {viewBounds: {left: 6, top: 2, right: 20, bottom: 16}, _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_0);specialKeys_v0_1 := {text: ":", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_1);specialKeys_v0_2 := {text: "_", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_2);specialKeys_v0_3 :=    {viewBounds: {left: -54, top: 20, right: -40, bottom: 34},     text: "{",     _proto: _v218_0    };AddStepForm(specialKeys, specialKeys_v0_3);specialKeys_v0_4 := {text: "}", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_4);specialKeys_v0_5 := {text: "{}", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_5);specialKeys_v0_6 :=    {viewBounds: {left: -54, top: 20, right: -40, bottom: 34},     text: "(",     _proto: _v218_0    };AddStepForm(specialKeys, specialKeys_v0_6);specialKeys_v0_7 := {text: ")", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_7);specialKeys_v0_8 := {text: "()", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_8);specialKeys_v0_9 :=    {viewBounds: {left: -54, top: 20, right: -40, bottom: 34},     text: "&",     _proto: _v218_0    };AddStepForm(specialKeys, specialKeys_v0_9);specialKeys_v0_10 := {text: "+", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_10);specialKeys_v0_11 := {text: "|", _proto: _v218_0};AddStepForm(specialKeys, specialKeys_v0_11);scriptEditor_v226_0 :=    {     buttonClickScript:       func()       begin       	:preSaveScript();       	if newMode then       		begin       			local uSoup := GetRoot().(kAppSymbol):GetScriptSoupRef();       			uSoup:AddToDefaultStoreXmit(editee, kAppSymbol); //in future check pref for always store internally       			resultMsg := "The new script \"" & editee.name & "\" was saved successfully.";       		end       	else       		begin       			EntryChangeXmit(editee, kAppSymbol);       			resultMsg := "Changes to the script \"" & editee.name & "\" were saved successfully.";       		end;       	:Parent():CLose();       end,     text: "Save",     viewBounds: {left: -60, top: -18, right: -6, bottom: -5},     lBounds: SetBounds(-60, -18, -6, -5),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(scriptEditor, scriptEditor_v226_0);scriptEditor_v226_0 :=    {     buttonClickScript:       func()       begin       	if changesMade then        		begin       			if ModalConfirm("Are you sure you want to discard the changes made to this script?", ["Discard and Close", "Cancel"]) = 0 then       				begin						       					if newMode then       						resultMsg := "The New Script operation was cancelled.";       					else       						begin       							resultMsg := "The Edit Script operation was cancelled. The changes to the \"" & editee.name  & "\" script were not saved.";       							EntryUndoChanges(editee);       						end;       					:parent():close();       				end;       		end       	else       		begin       			resultMsg := "The" && (if newMode then "New" else "Edit") && "Script operation was cancelled.";       			:Parent():Close();       		end;       end ,     text: "Cancel",     viewBounds: {left: -123, top: -18, right: -69, bottom: -5},     lBounds: SetBounds(-60,-37,-6,-24),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(scriptEditor, scriptEditor_v226_0);scriptEditor_v226_0 :=    {     buttonClickScript:       func()       begin       	:EditInfo();       end ,     text: "Edit Info",     viewBounds: {left: 68, top: -18, right: 122, bottom: -5},     lBounds: Setbounds(358,238,410,251),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then        		begin       			self.viewbounds := SetBounds(:Parent().viewBounds.right - 69, -66, :Parent().viewBounds.right - 15, -53);       		end;       		       		//self.viewBounds := self.lBounds;       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8388742,     _proto: @226 /* protoTextButton */    };AddStepForm(scriptEditor, scriptEditor_v226_0);scriptEditor_v226_0 :=    {     buttonClickScript:       func()       begin       	:preSaveScript();       	       	local canRun := NIL;       	       	try       		local testFunc := Compile(editee.scriptText);       		local canRun := TRUE       	onexception |evt.ex| do       		begin       			:Notify(kNotifyAlert, "Dash Board Compile Error", "The script code could not be compiled. Please check your code for any typos, syntax errors, or illegal characters and try again.");       			:Hilite(nil);       			ReThrow();       		end;              	:Hilite(nil);              	if canRun then       		if not ModalConfirm("The script was compiled successfully. Do you want to run it now?", 'yesNo) then return;       		       			GetRoot().(kDBSym):DBRunScript({type: 'script, text: editee.name, submenu: NIL, data: editee, icon: 'iScript});       	:Hilite(nil);       end,     text: "Test",     viewBounds: {left: 6, top: -18, right: 60, bottom: -5}     ,     lBounds: Setbounds(358,217,410,230),     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then        		begin       			self.viewbounds := SetBounds(:Parent().viewBounds.right - 69, -85, :Parent().viewBounds.right - 15, -72);       		end;       		       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8388742,     _proto: @226 /* protoTextButton */    };AddStepForm(scriptEditor, scriptEditor_v226_0);constant |layout_scriptEditor.t| := scriptEditor;// End of file scriptEditor.t// Beginning of file dbMenuSeparator.proto_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 6},     viewFlags: 513,     viewFormat: 0,     viewJustify: 9776,     height: 6,     viewClickScript:       func(unit)       begin       	Clicker();       	InkOff(Unit);       	:HiliteUnique(true);       	local dragResult := :DND(unit, :globalbox(), :Parent():globalbox(), nil, [{types: ['DBPMenuItem], view: self, dragRef: myIndex}]);       	       	if dragresult <> 2 then       		:Parent():HandleMenuHit(myIndex);       	true;       	// Return true if click has been completely handled, nil otherwise       end,     DND:       func(a,b,c,d,e)  //( unit, dragBounds, limitBounds, copy, dragInfo));       begin       	call kDragAndDropLtdFunc with (self,a,b,c,d,e);       end,     ViewDropMoveScript:       func(dragRef,offset,lastDragPt,copy)       begin       	return true;       	//return true or nil       end,     ViewDropRemoveScript:       func(dragRef)       begin       	:Hide();       	return true;       	//return true or nil       end,     ViewDropScript:       func(dropType,dropData,dropPt)       begin       	if debugOn then       		begin       			PRINT("DROPPED");       			PRINT(dropType);       			PRINT(dropData);       			PRINT(dropPT);       		end;       	       	local oldIndex, newIndex;       	oldIndex := dropdata.dropindex;              	       	if dropPt.y > :GlobalBox().top + 3 then  //dropped on top half of item       		begin       			if oldIndex < myIndex then       				newIndex := myIndex       			else       				newIndex := myIndex + 1;       		end       	else       		begin       			if oldIndex < myIndex then       				newIndex := myIndex - 1       			else        				newIndex := myIndex;       			       		end;       			       	if debugON then       		begin       			PRINT("OLD & NEW INDEX VALS:");       			PRINT(oldIndex);       			PRINT(newIndex);       		end;       	       	AddDeferredSend(:Parent(), 'AcidDrop, [oldIndex,newIndex]);       	       	//return true or nil       end,     ViewGetDropDataScript:       func(dragType,dragRef)       begin       	return {dropindex: myIndex};       	//return a frame containing the actual data to be dropped       end,     ViewGetDropTypesScript:       func(currentPoint)       begin       	return ['DBPMenuItem];       	//return an array of symbols       end,     ViewDropApproveScript:       func(destView)       begin       	if not destView then        		return NIL;       	else       		return TRUE;       	//return true or nil       end,     viewClass: 74 /* clView */    };_v74_0_v74_0 :=    {viewBounds: {left: 0, top: 3, right: 0, bottom: 4},     viewJustify: 8388660,     viewFlags: 1,     viewFormat: 3,     viewClass: 74 /* clView */    };AddStepForm(_v74_0, _v74_0_v74_0);constant |layout_dbMenuSeparator.proto| := _v74_0;// End of file dbMenuSeparator.proto// Beginning of file newtMenuPanel.tnewtMenuPanel :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 512,     viewFormat: 1,     viewJustify: 240,     DoHelp:       func(theMsg)       begin       	SetValue(helpText, 'text, theMsg);       end,     currentIndex: nil,     currentPath: '[pathExpr: nMenu],     RedoFakeMenu:       func()       begin       	       	//contentArea:RedoChildren();       	contentArea:redoLoc();	       	currentIndex := NIL;       	mcView:RedoChildren();       	:RefreshArrows();       	:DoHelp("Use the buttons at the left to add or remove items from the menu.");       	subNameBtn:Close();       end,     AddItem:       func(theItem)       begin              	local theIndex := if currentIndex = 0 then 0 else if currentIndex = NIL then Length( GetRoot().(kAppSymbol).myPrefs.(currentPath)) else currentIndex + 1;       	       	ArrayInsert(GetRoot().(kAppSymbol).myPrefs.(currentPath), DeepClone(theItem), theIndex);	       	:RedoFakeMenu();       	:ShowItem(theIndex);        	if theItem.type = 'sub then        		:DoSubName(GetRoot().(kAppSymbol).myPrefs.(currentPath)[theIndex], true, theIndex)       	else       		:DoHelp("Added \"" & theItem.text & "\" to the Newton Menu.");       end,     mcView: nil,     RefreshArrows:       func()       begin       	if mcView.scrolling then       		begin       			scroller:show();       			if mcView.index > 0 then       				scroller:SetArrow('up, 'more);       			else       				scroller:SetArrow('up, 'normal);       				       			if mcView.totalHeight - mcView.scrollOrigin <= mcView.boxHeight then       				scroller:SetArrow('down, 'normal);       			else       				scroller:setArrow('down, 'more);       		end       	else       		scroller:Hide();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	foreach i in removees do       		RemoveSlot(self,i);       	inherited:?ViewQuitScript();       end,     removees:       [       	'currentIndex,       	'currentPath,       	'mcView       ],     viewSetupDoneScript:       func()       begin       	:RefreshArrows();       end,     DoSubName:       func(theItem, nuMode, theIndex)       begin       	if theItem.type = 'sub then       		begin       			subOpts.myItem := theItem;       			subOpts.myCaller := self;       			subOpts.newMode := nuMode;       			subOpts.myIndex := theIndex;       			subOpts:Open();       		end       	else       		begin       			:DoHelp("The selected item does not have any options to set.");       		end;       end,     ShowItem:       func(theIndex)  //makes sure the item of theIndex is visible on screen. must call :RedoFakeMenu first       begin       	if not mcView.scrolling then return;       	       	       	local scrollAmt := 0;       	local theItems := mcView:ChildViewFrames();       	for i := 1 to theIndex + 1 do  						//NOTE: the 1 and +1  is nbecause element 0 is the aligner vieww       			scrollAmt := scrollAmt + theItems[i].height;       	       	scrollAmt := scrollAmt - mcView.boxHeight;       	       	if scrollAmt <= 0 then return;              	local realScrollAmt := 0;       	local realIndex := 0;       	for i := 1 to theIndex + 1 do       		begin       			realScrollAmt := realScrollAmt + theItems[i].height;       			realIndex := realIndex + 1;       			if realScrollAmt > scrollAMt then       				break;       		end;	       	       	mcView.scrollOrigin := realScrollAmt;       	mcView:SetOrigin(0, realScrollAmt);       	mcView.index := realIndex;       	:RefreshArrows();       	       		       end;       ,     viewClass: 74 /* clView */    };helpText :=    {text: "The Menu panel is where you customize Dash Board's Newton menu.",     viewBounds: {left: 8, top: 8, right: -8, bottom: 58},     viewJustify: 48,     viewFlags: 3,     viewFormat: 131664,     viewFont: ROM_fontSystem9,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewbounds := SetBounds(8,8,-8, 46);       	else       		self.viewbounds := SetBounds(8,8,-8, 58);       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(newtMenuPanel, helpText);StepDeclare(newtMenuPanel, helpText, 'helpText);toolArea :=    {viewBounds: {left: 5, top: 67, right: 133, bottom: -5},     viewFlags: 1,     viewFormat: 1,     viewJustify: 192,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := SetBounds(5,55,133,-5)       	else       		self.viewBounds := SetBounds(5,67,133,-5);       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(newtMenuPanel, toolArea);StepDeclare(newtMenuPanel, toolArea, 'toolArea);fuck :=    {text: "",     viewBounds: {left: 3, top: 0, right: 126, bottom: 0},     _proto: @218 /* protoStaticText */    };AddStepForm(toolArea, fuck);addPkgBtn :=    {text: "",     popup: [],     viewBounds: {left: -121, top: 29, right: -5, bottom: 44},     viewFlags: 515,     buttonClickScript:       func()       begin       	popup := :GetSortedPkgList();       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(itemSelected)       begin              	//local theIcon := 'iPackage; //disabled when we went to 'Runtime       	local chosenEntry := ResolveEntryAlias(popup[itemSelected].data);       	       	/*** disabled this shit when we went to all 'RunTime       	if chosenEntry then       			begin       				if chosenEntry.class = 'frozenEntry then        					theIcon := 'iSnowflake        				else if (chosenEntry.class = 'bookEntry) or (chosenEntry.class = 'helpBookENtry) then        					theIcon := 'iBook;       			end;       	********/              	local newItem := {type: 'pkg, text: popup[itemSelected].item, submenu: NIL, data: popup[itemSelected].data, icon: 'RunTime};       	:AddItem(newItem);       	popup := nil;       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	popup := nil;       	inherited:?PickCancelledScript();		// this method is defined internally       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(toolArea, addPkgBtn);addPkgBtn_v0_0 := {icon: 'iPackage, text: "Add Package", _proto: _v74_0};AddStepForm(addPkgBtn, addPkgBtn_v0_0);addFolderBtn :=    {text: "",     popup:       [       	"one",       	{item:"two", pickable: true, mark:kCheckMarkChar},       	"three",       	'pickseparator,       	"five",       ],     viewBounds: {left: -116, top: 51, right: 0, bottom: 66},     viewFlags: 515,     buttonClickScript:       func()       begin       	local symList := GetFolderList('extrasdrawer, TRUE);         	AddArraySlot(symList, '_help);       	AddArraySlot(symList, '_setup);       	AddArraySlot(symList, '_extensions);       	popup := [];       	local theText;       	foreach theSym in symList do       		begin       			theText := GetFolderStr(theSym);       			AddArraySlot(popup, {data: theSym, icon: GetRoot().|DashBoard:FiveSpeed|.iFolder, indent: 18, item: theText});       		end;       	Sort(popup, '|str<|, 'item);              	ArrayInsert(popup, {data: NIL, icon: GetRoot().|DashBoard:FiveSpeed|.iFOlder, indent: 18, item: GetFolderStr(NIL)}, 0);       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(itemSelected)       begin       	local theSym, theTxt;       	theSym := popup[itemSelected].data;       	theTxt := popup[itemSelected].item;       	local newItem := {type: 'folder, text:theTxt, submenu: TRUE, data: theSym, icon: 'iFolder};       	:AddItem(newItem);       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(toolArea, addFolderBtn);addFolderBtn_v0_0 := {icon: 'iFolder, text: "Add Folder", _proto: _v74_0};AddStepForm(addFolderBtn, addFolderBtn_v0_0);addSubBtn :=    {text: "",     viewBounds: {left: 5, top: 72, right: 121, bottom: 87},     viewFlags: 515,     buttonClickScript:       func()       begin       	local newItem := {type: 'sub, text: "Submenu", submenu: TRUE, data: [], icon: 'iMenu};       	:Hilite(nil);       	:AddItem(newItem);       end,     _proto: @226 /* protoTextButton */    };AddStepForm(toolArea, addSubBtn);addSubBtn_v0_0 := {icon: 'iMenu, text: "Add Submenu", _proto: _v74_0};AddStepForm(addSubBtn, addSubBtn_v0_0);addSpecialBtn :=    {text: "",     popup: [],     viewBounds: {left: -116, top: 93, right: 0, bottom: 108},     viewFlags: 515,     pickActionScript:       func(itemSelected)       begin       	local newItem := popup[itemSelected].data;       	:AddItem(newItem);       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     buttonClickScript:       func()       begin       	popup := :GetNMenuSpecials(true);       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(toolArea, addSpecialBtn);addSpecialBtn_v0_0 :=    {icon: 'iSpecials, text: "Add Special Item", _proto: _v74_0};AddStepForm(addSpecialBtn, addSpecialBtn_v0_0);addScriptBtn :=    {text: "",     popup: [],     viewBounds: {left: -116, top: 114, right: 0, bottom: 129},     viewFlags: 515,     pickActionScript:       func(itemSelected)       begin       	local newItem := {type: 'script, text: popup[itemSelected].item, submenu: NIL, data: popup[itemSelected].data, icon: 'iScript};       	:AddItem(newItem);       	popup := NIL;       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     buttonClickScript:       func()       begin       	       	local sList := :GetScriptList();       	       	if sList then       		popup := sList;       	else       		popup := [ {item: "(No Scripts Available)", pickable: NIL} ];       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(toolArea, addScriptBtn);addScriptBtn_v0_0 := {icon: 'iScript, text: "Add Script", _proto: _v74_0};AddStepForm(addScriptBtn, addScriptBtn_v0_0);remBtn :=    {text: "Remove Selected Item",     viewBounds: {left: 5, top: 142, right: 121, bottom: 157},     viewFlags: 515,     buttonClickScript:       func()       begin       	       	if currentIndex then       		begin       			local deleteIndex := currentIndex;       			local selItem := GetRoot().(kAppSymbol).myPrefs.(currentPath)[currentIndex].text;       			if GetRoot().(kAppSymbol).myPrefs.(currentPath)[currentIndex].type = 'sub then       				begin       					if not ModalConfirm("Are you sure you want to remove the selected Custom Submenu, \"" & selItem & "\", and all of its contents? This operation cannot be undone.", 'yesNo) then        						begin       							:RedoFakeMenu();       							:ShowItem(Max(0,deleteIndex));       							:DoHelp("The Remove Selected Item operation was cancelled.");       							return NIL;       						end;       				end;       			ArrayRemoveCount(GetRoot().(kAppSymbol).myPrefs.(currentPath), currentIndex, 1);       			:RedoFakeMenu();       			:ShowItem(Max(0,deleteIndex - 1));       			:DoHelp("The Custom Submenu \"" & selItem & "\" was deleted from the Newton Menu.");              		end       	else       		begin       			:SysBeep();       			:DoHelp("No menu item is selected. To remove a menu item, tap its name in the list to select it, then press the Remove Selected Item button.");       		end;       end,     _proto: @226 /* protoTextButton */    };AddStepForm(toolArea, remBtn);contentArea :=    {viewBounds: {left: 136, top: 67, right: -5, bottom: -5},     viewFlags: 1,     viewFormat: 0,     viewJustify: 240,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := SetBounds(136,55,-5,-5)       	else       		self.viewBounds := SetBounds(136,67,-5,-5);       		       	inherited:?ViewSetupFormScript();       end,     scrolling: nil,     LArrow:       func(onOrOff)       begin       	if onOrOff then       		begin       			SetValue(leftArrow, 'icon, leftArrow.icon2);       			SetValue(leftArrow, 'enabled, true);       		end       	else       		begin       			SetValue(leftArrow, 'icon, leftArrow.icon1);       			SetValue(leftArrow, 'enabled, NIL);       		end;       end,     RArrow:              func(onOrOff)       begin       	if onOrOff then       		begin       			SetValue(rightArrow, 'icon, rightArrow.icon2);       			SetValue(rightArrow, 'enabled, true);       		end       	else       		begin       			SetValue(rightArrow, 'icon, rightArrow.icon1);       			SetValue(rightArrow, 'enabled, NIL);       		end;       end,     HandleMenuHit:       func(hitIndex)       begin       	currentIndex := hitIndex;       	local hitData := GetRoot().(kAppSymbol).myPrefs.(currentPath)[hitIndex];       	local theType := hitData.type;       	:RArrow(nil);       	local openSub := NIL;       	       	if theType = 'sub then       		begin       			openSub := true;       			:RArrow(true);       			:DoHelp("The selected item is a Custom Submenu. Tap the right arrow to edit its contents." && kMoveHelp);       		end       	else if theType = 'pkg then       		begin        			:DoHelp("The selected item is a package. Choosing it from the Newton Menu will launch the package."  && kMoveHelp);       		end       	else if theType = 'folder then       		begin       			:DoHelp("The selected item is a Folder Submenu. Choosing it from the Newton Menu will display a submenu listing the packages in the corresponding Extras Drawer folder."  && kMoveHelp);       		end       	else if theType = 'separator then       		begin       			:DoHelp("The selected item is a menu separator."  && kMoveHelp);       		end       	else if theType = 'script then       		begin       			:DoHelp("The selected item is a script. Choosing the item from the Newton Menu will execute the script."  && kMoveHelp);       		end       	else       		begin       			:DoHelp(:GetHelpStr(hitData.data, hitData.text, hitData.type));       			//:DoHelp("The selected item is a Special Item. Choosing the item from the Newton Menu will make Dash Board perform that command. You can move it within the menu by dragging it, or delete it by tapping the Remove Selected item button.");       		end;       		       	if openSub then        		subNameBtn:Open()       	else       		subNameBtn:Close();       end,     redoLoc:       func()       begin       	:Larrow(nil);       	:RArrow(nil);       	locTxt:Close();       	menuNameTxt:CLose();       	locTxt:Open();       	menuNameTxt:Open();       	       	if Length(currentPath) > 1 then :LArrow(true);       end,     viewClass: 74 /* clView */    };AddStepForm(newtMenuPanel, contentArea);StepDeclare(newtMenuPanel, contentArea, 'contentArea);leftArrow :=    {viewBounds: {left: 0, top: 0, right: 24, bottom: 24},     viewFlags: 513,     viewFormat: nil,     icon2:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     enabled: nil,     viewClickScript:       func(unit)       begin              	if self.enabled then       		begin       			Clicker();       			local newPath := Clone(currentPath);       			ArrayRemoveCount(newPath, (Length(NewPath) - 2), 2);       			currentPath := newPath;       			if Length(currentPath) = 1 then        				:LArrow(nil);       			       			:RedoFakeMenu();       			RefreshViews();       		end;       		       	true;              	// Return true if click has been completely handled, nil otherwise       end,     icon1:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(contentArea, leftArrow);StepDeclare(contentArea, leftArrow, 'leftArrow);rightArrow :=    {viewBounds: {left: -24, top: 0, right: 0, bottom: 24},     viewFlags: 513,     viewFormat: nil,     icon2:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 2}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 2}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     viewJustify: 38,     enabled: nil,     viewClickScript:       func(unit)       begin              	if self.enabled then       		begin       		Clicker();       		local newPath := Clone(currentPath);       			AddArraySlot(newPath, currentIndex);       			AddArraySlot(newPath, 'data);       			currentPath := newPath;       			:LArrow(true);       			:RArrow(nil);       			       			:RedoFakeMenu();       			RefreshViews();       		end;       	true;              	// Return true if click has been completely handled, nil otherwise       end,     icon1:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	inherited:?ViewSetupFormScript();       end,     viewClass: 76 /* clPictureView */    };AddStepForm(contentArea, rightArrow);StepDeclare(contentArea, rightArrow, 'rightArrow);locTxt :=    {text: "Menu Type",     viewBounds: {left: 24, top: 1, right: -24, bottom: 11},     viewFont: {family: 'geneva, face: kFaceNormal, size: 9},     viewJustify: 8388658,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local pLength := Length(currentPath);       	       	if pLength = 1 then       		self.text := "Main Menu (Top Level)"       	else if pLength = 3 then       		self.text := "Submenu";       	else       		self.text := "Submenu (level " & pLength div 2 & ")";       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(contentArea, locTxt);StepDeclare(contentArea, locTxt, 'locTxt);menuNameTxt :=    {text: "Menu Name",     viewBounds: {left: 24, top: 11, right: -24, bottom: 25},     viewFont: ROM_fontSystem10Bold,     viewJustify: 8388666,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local pLength := Length(currentPath);       	       	if pLength = 1 then       		self.text := "Newton Menu"       	else        		begin       			local halfPath := CLone(currentPath);       			ArrayRemoveCount(halfPath, Length(HalfPath) - 1 , 1);       			self.text := GetRoot().(kAppSymbol).myPrefs.(halfPath).text;       		end;       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(contentArea, menuNameTxt);StepDeclare(contentArea, menuNameTxt, 'menuNameTxt);menuContents :=    {     ViewDropRemoveScript:       func(dragRef)       begin       	if debugOn then       		PRINT("VIEW DROP REMOVE SCRIPT --why is this being called?"); //never called?       	//return true or nil       end,     viewSetupDoneScript:       func()       begin       	mcView := self;       end,     viewFormat: 67109456,     ViewGetDropDataScript:       func(dragType,dragRef)       begin       	nil;       		//return a frame containing the actual data to be dropped       end,     ViewGetDropTypesScript:       func(currentPoint)       begin       	return ['DBPMenuItem];       	//return an array of symbols       end,     viewFlags: 545,     totalHeight: nil,     scrolling: nil,     viewBounds: {left: 2, top: 29, right: -2, bottom: -2},     index: 0,     DB_ScrollDown:       func()       begin       	if self.index = Length(GetRoot().(kAppSymbol).myPrefs.(currentPath))  then //make betr latr       		ProtoPerformIfDefined(NoMore, 'PlayStopSound, NIL);        	else       		begin       			self.index := self.index + 1;       			:RedoFakeMenu();       		end;       	       end,     ViewDropScript:       func(dropType,dropData,dropPt)       begin              	local oldIndex, newIndex;       	oldIndex := dropdata.dropindex;              	AddDeferredSend(self, 'AcidDrop, [oldIndex,'bottom]);       	       	return true;       	       	//return true or nil       end,     viewJustify: 240,     boxHeight: nil,     ViewScroll2DScript:       func(dir, extras)       begin       	local scrollAmt;              	if dir = 'up then       		begin       			if index = 0 then       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					index := index - 1;       					if GetRoot().(kAppSymbol).myPrefs.(currentPath)[index].type = 'separator then       						scrollAmt := 6       					else       						scrollAmt := 13;       					scrollorigin := scrollOrigin - scrollAmt;       					//:RedoFakeMenu();       				end;       		end       	else       		begin       			if (totalHeight - scrollOrigin) <= boxHeight then //then no more scroll down       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					if GetRoot().(kAppSymbol).myPrefs.(currentPath)[index].type = 'separator then       						scrollAmt := 6       					else       						scrollAmt := 13;       					index := index + 1;       					scrollorigin := scrollOrigin + scrollAmt;       					//:RedoFakeMenu();       				end;       		end;       	       	:SetOrigin(0, scrollOrigin);       	:RefreshArrows();       	RefreshViews();       end;,     DB_ScrollUp:       func()       begin       	if self.index = 0 then       		ProtoPerformIfDefined(NoMore, 'PlayStopSound, NIL);        	else       		begin       			self.index := self.index - 1;       			:RedoFakeMenu();       		end;       end,     AcidDrop:       func(oldIndex,newIndex)       begin       	local itemtoShow;       	local theItem := DeepClone(GetRoot().(kAppSymbol).myPrefs.(currentPath)[oldIndex]);       	ArrayRemoveCount(GetRoot().(kAppSymbol).myPrefs.(currentPath), oldIndex, 1);       	       	if newIndex = 'bottom then       		begin       			AddArraySlot(GetRoot().(kAppSymbol).myPrefs.(currentPath), theItem);       			itemToShow := Length(GetRoot().(kAppSymbol).myPrefs.(currentPath)) - 1;       		end       	else       		begin       			ArrayInsert(GetRoot().(kAppSymbol).myPrefs.(currentPath), theItem, newIndex);       			itemToShow := newIndex;       		end;       			       	:RedoFakeMenu();       	:ShowItem(itemToShow);       end,     ViewDropMoveScript:       func(dragRef,offset,lastDragPt,copy)       begin       	if debugOn then       		PRINT("VIEW DROP MOOOVE SCRIPT!  why the hell is this being called?"); //this is never called?       	return true;       	//return true or nil       end,     total: 0,     viewClass: 74 /* clView */,     myFit: 0,     viewSetupChildrenScript:       func()       begin       	foreach i in '[index, scrolling, myFit, total, totalHeight, boxHeight, scrollOrigin, viewOriginX, viewOriginY, stepChildren] do       		RemoveSlot(self, i);       		       	local theTitle;       	local theIcon;       	self.stepChildren := Clone(self.stepchildren);       	local theIndex := index;       	local theHeight := 0;       	boxHeight := :localBox().bottom - :LocalBox().top;       	totalHeight := 0;       	total := Length(GetRoot().(kAppSymbol).myPrefs.(currentPath));       	       	if total = 0 then        		begin       			self.scrolling := NIL;       			if scroller.viewCObject then        				scroller:Hide();       			return;  //if no menu data then die       		end;       	       		foreach i in GetRoot().(kAppSymbol).myPrefs.(currentPath) do       		begin       			theHeight := 13;       			theTitle := Clone(i.text);        			       			if i.icon = 'runtime then       				theIcon := :GetRuntimeIcon(i.data)       			else       				theIcon := GetRoot().|DashBoard:FiveSpeed|.(i.icon);         			       			if (i.type = 'sub) or (i.type = 'dynSub) then       					local theMenuItem := {_proto: GetLayout("DBP_MenuItem.proto"), text: theTitle, hasSub: true, icon: theIcon}       			else if i.type = 'separator then       				begin       					theHeight := 6;       					local theMenuItem := {_proto: GetLayout("dbMenuSeparator.proto")};       				end       			else if i.type = 'folder then       				local theMenuItem := {_proto: GetLayout("DBP_MenuItem.proto"), text: theTitle,  hasSub: true, icon: theIcon}       			else if i.type = 'pkg then       				local theMenuItem := {_proto: GetLayout("DBP_MenuItem.proto"), text: theTitle, hasSub: NIL, icon: theIcon}       			else if i.type = 'disabled then       				local theMenuItem := {_proto: GetLayout("DBP_MenuItemDisabled.proto"), text: theTitle, hasSub: NIL, icon: theIcon}	       			else       				local theMenuItem := {_proto: GetLayout("DBP_MenuItem.proto"), text: theTitle,  hasSub: NIL, icon: theIcon};       				       			theMenuItem.myIndex := theIndex;       			theIndex := theIndex + 1;       			totalHeight := theHeight + totalHeight;       			if totalHeight < boxHeight then        				myFit := myFit + 1;       			AddArraySlot(self.stepChildren, theMenuItem);       		end;              	if (totalHeight > boxHeight) or (index > 0) then       		begin       			self.scrolling := true;        		end       	else       		begin       			self.scrolling := NIL;       		end;       	:SetOrigin(0,scrollorigin);       	              end,     scrollOrigin: 0    };AddStepForm(contentArea, menuContents);StepDeclare(contentArea, menuContents, 'menuContents);aligner :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 0,     viewJustify: 48,     height: 0,     viewClass: 74 /* clView */    };AddStepForm(menuContents, aligner);scroller :=    {viewFlags: 65,     viewJustify: 5216,     ViewScroll2DScript:       func(direction,extras)       begin       	ContentArea.menuCOntents:viewScroll2dScript(direction,extras);       end,     _proto: @656 /* protoUpDownScroller */    };AddStepForm(newtMenuPanel, scroller);StepDeclare(newtMenuPanel, scroller, 'scroller);noMore :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     _proto: @656 /* protoUpDownScroller */    };AddStepForm(newtMenuPanel, noMore);StepDeclare(newtMenuPanel, noMore, 'noMore);subNameBtn :=    {text: "Submenu Name...",     viewBounds: {left: 10, top: 235, right: 126, bottom: 250},     viewFlags: 514,     buttonClickScript:       func()       begin       	       	if currentIndex then       		begin       			local selItem := GetRoot().(kAppSymbol).myPrefs.(currentPath)[currentIndex];       			:DoSubName(selItem, nil,currentIndex);       		end       	else       		begin       			:SysBeep();       			:DoHelp("No menu item is selected. To change an item's options, tap its name in the list to select it, then press the Item Options button. Note that many items do not have options.");       		end;       end,     _proto: @226 /* protoTextButton */    };AddStepForm(newtMenuPanel, subNameBtn);StepDeclare(newtMenuPanel, subNameBtn, 'subNameBtn);constant |layout_newtMenuPanel.t| := newtMenuPanel;// End of file newtMenuPanel.t// Beginning of file letterLauncherPanel.tletterLauncherPanel :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 512,     viewFormat: 1,     viewJustify: 240,     currentSelection: nil,     DoEdit:       func(theIndex)       begin       	:SetHelp("");       	LLEdit.myData := DeepClone(GetRoot().(kAppSymbol).myPrefs.LLCmds[theIndex]);       	LLEdit.editMode := true;       	LLEdit.editIndex := theIndex;       	LLEdit.refreshee := theList;       	LLEdit.resultView := theHelp;       	LLEdit:Open();              end                                          ,     DoNew:       func()       begin       	LLEdit.refreshee := theList;       	LLEdit.resultView := theHelp;       	LLEdit:Open();       end,     theList: nil,     theHelp: nil,     viewSetupDoneScript:       func()       begin       	       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	:DeathPenalty();       	inherited:?ViewQuitScript();       end,     SelectAll:       func(theBool)       begin       	foreach i in theList:ChildViewFrames() do       		begin       			ProtoPerformIfDefined(i, 'DoSelect, [theBool]);       		end;       	       		       end,     GetSelectedItems:       func() //returns array of llcmd indexes, for deletion (REVERSE SORTED OF COURSE!_)       begin       	local selectees := [];       	foreach i in theList:ChildViewFrames() do       		begin       			if i.selected then       				AddArraySlot(selectees, i.myIndex);       		end;       		       	if Length(selectees) = 0 then       		selectees := NIL;       	else       		Sort(selectees, '|>|, nil);       	       	return selectees;              end,     deathRow:       '[       	currentSelection,       	theHelp,       	theList,       ],     DeleteSelected:       func()       begin       	local theVictims := :GetSelectedItems();       	if not theVictims then       		begin       			:SysBeep();       			:SetHelp("There are no shortcuts currently selected. To select a shortcut, tap the checkbox next to its name in the list.");       			return;       		end;       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := GetRoot().(kAppSymbol).myPrefs.LLCmds[theVictims[0]];       			vicName := "\"" & Clone(theVictim.name) & "\"shortcut";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected shortcuts";       			helpPhrase := vicName && "were";       		end;       		       	if ModalConfirm("Are you sure you want to delete the " & vicName & "? This operation cannot be undone, so please be sure that this is what you want to do.", ["Delete", "Cancel"]) = 0 then       		begin       			foreach i in theVictims do       					ArrayRemoveCount(GetRoot().(kAppSymbol).myPrefs.LLCmds, i, 1);       							       				:SetHelp("The " & helpPhrase & " deleted successfully.");        			       			theList:Delete('RefreshList,[]);       		end       	else       		:SetHelp("The Delete operation was cancelled.");       end;,     SetHelp:       func(theTxt)       begin       	SetValue(theHelp, 'text, theTxt);       end,     SelMade:       func()       begin       	:SetHelp("The Launcher panel allows you to create shortcuts for use with the Letter Launcher." &&       		"To select a shortcut, tap the checkbox next to its name. To edit a shortcut, tap its name in the list.");       end,     RefreshList:       func()       begin       	theList:RedoChildren();       end,     viewClass: 74 /* clView */    };letterLauncherPanel_v218_0 :=    {     text:       "The Launcher panel is where you can add, modify, or remove Letter Launcher shortcuts."     ,     viewBounds: {left: 8, top: 8, right: -8, bottom: 58},     viewJustify: 48,     viewFlags: 3,     viewFormat: 131664,     viewFont: ROM_fontSystem9,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewbounds := SetBounds(8,8,-8, 46);       	else       		self.viewbounds := SetBounds(8,8,-8, 58);       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	theHelp := self;       end,     _proto: @218 /* protoStaticText */    };AddStepForm(letterLauncherPanel, letterLauncherPanel_v218_0);letterLauncherPanel_v74_0 :=    {viewBounds: {left: 5, top: 67, right: 111, bottom: -5},     viewFlags: 1,     viewFormat: 0,     viewJustify: 192,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := SetBounds(5,55,133,-5)       	else       		RemoveSlot(self, 'viewBounds);       		inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(letterLauncherPanel, letterLauncherPanel_v74_0);letterLauncherPanel_v74_0_v0_0 :=    {     buttonClickScript:       func()       begin       	:DoNew();       end,     viewBounds: {left: 0, top: 2, right: 102, bottom: 20},     myText: "New Shortcut",     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 152}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(letterLauncherPanel_v74_0, letterLauncherPanel_v74_0_v0_0);letterLauncherPanel_v74_0_v0_1 :=    {     buttonClickScript:       func()       begin       	:DeleteSelected();       end	                     ,     viewBounds: {left: 0, top: 29, right: 102, bottom: 47},     myText: "Delete",     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1304}),           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1304}),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1304}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(letterLauncherPanel_v74_0, letterLauncherPanel_v74_0_v0_1);letterLauncherPanel_v74_0_v226_0 :=    {     buttonClickScript:       func()       begin       	:SelectAll(true)       end,     text: kCheckMarkChar & "All",     viewBounds: {left: -33, top: -15, right: -2, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(letterLauncherPanel_v74_0, letterLauncherPanel_v74_0_v226_0);letterLauncherPanel_v74_0_v226_0 :=    {     buttonClickScript:       func()       begin       	:SelectAll(nil)       end,     text: "      All",     viewBounds: {left: -73, top: -15, right: -42, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(letterLauncherPanel_v74_0, letterLauncherPanel_v74_0_v226_0);letterLauncherPanel_v74_0_v226_0_v204_0 :=    {indent: 0,     text: "",     viewBounds: {left: 2, top: -1, right: 17, bottom: 15},     viewFlags: 1,     _proto: @204 /* protoRCheckBox */    };AddStepForm(letterLauncherPanel_v74_0_v226_0,letterLauncherPanel_v74_0_v226_0_v204_0);contentHolder :=    {viewBounds: {left: 116, top: 67, right: -5, bottom: -5},     viewFlags: 1,     viewFormat: 0,     viewJustify: 240,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := SetBounds(136,55,-5,-5)       	else       		RemoveSlot(self, 'viewBounds);       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       		if theList.scrolling then       			scroller:show()       		else       			scroller:hide();       		       		theList.scrollSafe := true;       end,     viewClass: 74 /* clView */    };AddStepForm(letterLauncherPanel, contentHolder);cmdHolder :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewFlags: 33,     viewFormat: 592,     viewJustify: 240,     viewSetupDoneScript:       func()       begin       	theList := self;       end,     index: 0,     ViewScroll2DScript:       func(dir, extras)       begin       	if dir = 'up then       		begin       			if index = 0 then       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					index := index - 1;       					:setOrigin(0, index * 13);       				end;       		end       	else       		begin       			if (total - index) <= myFit then //then no more scroll down       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					index := index + 1;       					:setOrigin(0, index * 13);       				end;       		end;       	       	:RefreshArrows();       	RefreshViews();       end;,     viewSetupChildrenScript:       func()       begin       	if debugOn then PRINT("calling LLPanel cmdHolder viewSetupChildrenScript>>=-=->>=-=-=>>>>=-=-==>>=-=-=-=-=-=-=-=!!===:<><><<><><:<><:<><:");       	nameWidth := :LocalBox().right - :localBox().left - 62; //width of cmd name       	RemoveSlot(self, 'stepchildren);       	self.stepChildren := Clone(self.stepchildren);       	local theIndex := 0;       	total :=  Length(Sort(GetRoot().(kAppSymbol).myPrefs.LLCmds, '|str<|, 'Name));       	foreach i in GetRoot().(kAppSymbol).myPrefs.LLCmds do       		begin       			local theItem := {_proto: GetLayout("ltrCmdItem.proto")};       			theItem.myLtr := i.Name;       			theItem.myTitle := i.cmdItem.text;       			theItem.myIcon := i.cmdItem.icon;       			theItem.myIndex := theIndex;       			AddArraySlot(self.stepchildren, theItem);       			theIndex := theIndex + 1;       		end;       		       	if Length(GetRoot().(kAppSymbol).myPrefs.LLCmds) = 0 then       		emptyMsg:Open()       	else       		if emptyMsg.viewCObject then emptyMsg:CLose();       	       	myFit := (:LocalBox().bottom - :LocalBox().top) div 13;       	       	if total > myFit then        		self.scrolling := true       	else       		self.scrolling := NIL;              	if scrollSafe then //should be NIL on first setup, and true after that       	begin       		if scrolling then        			begin       				Scroller:Show();       				//AddDeferredSend(scroller, 'MoveBehind, [nil]);       				//AddDeferredSend(self, 'RefreshArrows, nil);       				AddDeferredCall(func() begin if scroller and scroller.viewCObject then scroller:MoveBehind(NIL); end, NIL);       				AddDeferredCall(func() begin if self and self.viewCObject then self:RefreshArrows(); end, NIL); //CHANGED 990813       			end       		else       			Scroller:Hide();       	end;       end,     RefreshArrows:       func()       begin       	if index > 0 then       		scroller:SetArrow('up, 'more);       	else       		scroller:SetArrow('up, 'normal);       		       	if total - index > myFit then       		scroller:SetArrow('down, 'more);       	else       		scroller:setArrow('down, 'normal);       end,     myFit: nil,     total: 0,     nameWidth: 0,     scrollSafe: nil,     deathRow:       '[       	index,       	myFit,       	nameWidth,       	scrollSafe,       	total,       	stepChildren       ],     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	:DeathPenalty();       	inherited:?ViewQuitScript();       end,     viewClass: 74 /* clView */    };AddStepForm(contentHolder, cmdHolder);StepDeclare(contentHolder, cmdHolder, 'cmdHolder);emptyMsg :=    {     text:       "There are no shortcuts defined. Tap the Add New Shortcut button to create one."     ,     viewBounds: {left: 6, top: 91, right: 166, bottom: 211},     viewFont: ROM_fontSystem10Bold,     viewFlags: 2,     viewJustify: 6,     _proto: @218 /* protoStaticText */    };AddStepForm(cmdHolder, emptyMsg);StepDeclare(cmdHolder, emptyMsg, 'emptyMsg);aligner :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 0,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(cmdHolder, aligner);scroller :=    {viewFlags: 65,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	scrollview := cmdHolder;       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	cmdHolder:RefreshArrows();       end,     _proto: @656 /* protoUpDownScroller */    };AddStepForm(contentHolder, scroller);StepDeclare(contentHolder, scroller, 'scroller);constant |layout_letterLauncherPanel.t| := letterLauncherPanel;// End of file letterLauncherPanel.t// Beginning of file scriptPanel.tscriptPanel :=    {     RefreshList:       func()       begin       	theList:RedoChildren();       end,     FileSelectedFinish:       func(theStore)       begin       	local theVictims := :GetSelectedItems();       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := ResolveEntryAlias(theVictims[0]);       			if theVictim = NIL then       				begin       					:SetHelp("The script could not be found! That means that a weird error occurred. Very sorry.");       					:RefreshList();       					return;       				end;       			vicName := "\"" & Clone(theVictim.name) & "\"script";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected scripts";       			helpPhrase := vicName && "were";       		end;              	local missingCount := 0;       	local lockedCount := 0;       	local okCount := 0;       	local uSOup := :GetScriptSoupRef();       	local tSoup := uSoup:GetMember(theStore);       	       	foreach i in theVictims do       		begin       			local theVic := ResolveEntryAlias(i);       			if theVic then       				begin       					if not theStore:IsReadOnly() then       						begin       							EntryMoveXmit(theVic, tSoup, kAppSymbol);       							okCount := okCount + 1;       						end       					else       						lockedCount := lockedCount + 1;       				end       			else       				missingCount := missingCount + 1;       		end;       		       	if okCount = Length(theVictims) then       		:SetHelp("The " & helpPhrase & " filed on store \"" & theStore:GetName() & "\" successfully.");        	else //set help to list error conditions.       		begin       			:SysBeep();       			local errTotal := missingCount + lockedCount;       			local errTxt := :ScriptScripts(errTotal) && "(out of " & Length(theVictims) & ") could not be filed." &&        				(if missingCount <> 0 then missingCount && "could not be found.") &&       				(if lockedCount <> 0 then lockedCount &&  "could not be duplicated because the \"" & theStore:GetName() & "\" is write-protected.");       			:SetHelp(errTxt);        		end;       		       	:RefreshList();       	//theList:Effect(fxMoveH+fxHStartPhase+fxSteps(6)+fxStepTIme(8),nil, @380,'RefreshList,[]);  //change sound LATER?              end;,     viewFormat: 1,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	foreach i in deathRow do        		RemoveSlot(self, i);       	inherited:?ViewQuitScript();       end,     DupeSelected:       func()       begin       	local theVictims := :GetSelectedItems();       	if not theVictims then       		begin       			:SysBeep();       			:SetHelp("There are no scripts currently selected. To select a script, tap the checkbox next to its name in the list.");       			return;       		end;       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := ResolveEntryAlias(theVictims[0]);       			if theVictim = NIL then       				begin       					:SetHelp("The script could not be found! That means that a weird error occurred. Very sorry.");       					:RefreshList();       					return;       				end;       			vicName := "\"" & Clone(theVictim.name) & "\"script";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected scripts";       			helpPhrase := vicName && "were";       		end;       		       	if Length(theVictims) > 5 then       		begin       			if ModalConfirm("You have" && Length(theVictims) && "scripts selected. Are you sure you want to duplicate them all?", ["Yes, Duplicate Them All", "Cancel"]) = 1 then       				begin       					:SetHelp("The Duplicate operation was cancelled.");       					return;       				end;       		end;       		       	local missingCount := 0;       	local lockedCount := 0;       	local okCount := 0;       	local uSOup := :GetScriptSoupRef();       	local dStore := GetDefaultStore();       	local tSoup := uSoup:GetMember(dStore);       	       	foreach i in theVictims do       		begin       			local theVic := ResolveEntryAlias(i);       			if theVic then       				begin       					if not dStore:IsReadOnly() then       						begin       							local theDupe := EntryCopyXmit(theVic, tSoup, kAppSymbol);       							theDupe.Name := theDupe.Name && "copy";       							EntryChangeXmit(theDupe, kAppSymbol);       							okCount := okCount + 1;       						end       					else       						lockedCount := lockedCount + 1;       				end       			else       				missingCount := missingCount + 1;       		end;       		       	if okCount = Length(theVictims) then       		:SetHelp("The " & helpPhrase & " duplicated successfully.");        	else //set help to list error conditions.       		begin       			:SysBeep();       			local errTotal := missingCount + lockedCount;       			local errTxt := :ScriptScripts(errTotal) && "(out of " & Length(theVictims) & ") could not be duplicated." &&        				(if missingCount <> 0 then missingCount && "could not be found.") &&       				(if lockedCount <> 0 then lockedCount &&  "could not be duplicated because the \"" & dStore:GetName() & "\" is write-protected.");       			:SetHelp(errTxt);        		end;       		       	theList:Effect(fxMoveH+fxHStartPhase+fxSteps(6)+fxStepTIme(8),nil, @380,'RefreshList,[]);                end;,     viewFlags: 512,     SelMade:       func()       begin       	:SetHelp("The Script panel allows you to create custom scripts, which can be run from the menu or from the Letter Launcher." &&       		"To select a script, tap the checkbox next to its name. To edit a script, tap its name in the list.");       end,     theList: nil,     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     DeleteSelected:       func()       begin       	local theVictims := :GetSelectedItems();       	if not theVictims then       		begin       			:SysBeep();       			:SetHelp("There are no scripts currently selected. To select a script, tap the checkbox next to its name in the list.");       			return;       		end;       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := ResolveEntryAlias(theVictims[0]);       			vicName := "\"" & Clone(theVictim.name) & "\"script";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected scripts";       			helpPhrase := vicName && "were";       		end;       		       	if ModalConfirm("Are you sure you want to delete the " & vicName & "? This operation cannot be undone, so please be sure that this is what you want to do.", ["Delete", "Cancel"]) = 0 then       		begin       			local missingCount := 0;       			local lockedCount := 0;       			local okCount := 0;       			foreach i in theVictims do       				begin       					local theVic := ResolveEntryAlias(i);       					if theVic then       						begin       							if not EntryStore(theVic):IsReadOnly() then       								begin       									EntryRemoveFromSoupXmit(theVic, kAppSymbol);       									okCount := okCount + 1;       								end       							else       								lockedCount := lockedCount + 1;       						end       					else       						missingCount := missingCount + 1;       				end;       			if okCount = Length(theVictims) then       				:SetHelp("The " & helpPhrase & " deleted successfully.");        			else //set help to list error conditions.       				begin       					local errTotal := missingCount + lockedCount;       					local errTxt := :ScriptScripts(errTotal) && "could not be deleted." &&        						(if missingCount <> 0 then missingCount && "could not be found.") &&       						(if lockedCount <> 0 then lockedCount && :WasWere(lockedCount) && "stored in read only memory.");       					:SetHelp(errTxt);        				end;       			//:RefreshList();       			theList:Delete('RefreshList,[]);       		end       	else       		:SetHelp("The Delete operation was cancelled.");       end;,     SetHelp:       func(theMsg)       begin       	SetValue(helpText, 'text, theMsg);       end,     ExportSelected:       func(exportType)  //'notes or 'packMan       begin       	local theVictims := :GetSelectedItems();       	if not theVictims then       		begin       			:SysBeep();       			:SetHelp("There are no scripts currently selected. To select a script, tap the checkbox next to its name in the list.");       			return;       		end;       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := ResolveEntryAlias(theVictims[0]);       			vicName := "\"" & Clone(theVictim.name) & "\"script";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected scripts";       			helpPhrase := vicName && "were";       		end;       		       	if exportType = 'notes then       		begin       			local missingCount := 0;       			local okCount := 0;       			foreach i in theVictims do       				begin       					local theVic := ResolveEntryAlias(i);       					if theVic then       						begin       							local expText := "//Dash Board Script Export()\n//Exported" && DateNTime(time()) & "\n";       							expText := expText & theVic.scriptText;       							GetRoot().paperroll:MakeTextNote(expText, true);       						end       					else       						missingCount := missingCount + 1;       				end;       		end       		       	else if exportType := 'packMan then       		begin       			//LATER - get pkg name maybe       			if not GetRoot().|packMan:ICS| then       				begin       					:Notify(kNotifyAlert, "Dash Board Export", "To export scripts to a Newton package which you can share with others, you need to have PackMan installed." &&       						"PackMan is available from Innovative Computer Solutions\n(http://www.newts.com)");       					:SetHelp("The Export to Newton Package operation could not be completed, because PackMan from ICS is not currently installed.");        					:RefreshList();       					return NIL;       				end;       				       			GetRoot().(kAppSymbol).PackManNameSlip:ModalDialog();       			       			local expPkgName := GetRoot().(kAppSymbol).expPkgName;       			       			if expPkgName = NIL then  //then die       				begin       					:SetHelp("The Export to Newton Package operation was cancelled.");        					:RefreshList();       					return NIL;       				end;       			       			local expPkgExtrasName := GetRoot().(kAppSymbol).expPkgExtrasName;       			       			//LATER! got to more betterly get the selected scripts ONLY.       				       			local idList := [];       			foreach i in theVictims do       				begin       					AddArraySlot(idList, i);       				end;              			gc();       			local theCurse:= :GetScriptSoupRef():Query({validtest:func(theEntry)        				begin       					//BFind(idList,theEntry.id,'|sym<|,nil); //OLD IMPRECISE SHIT (cuz DB ids arent guaranteed unique);       					foreach i in idList do       						begin       							if IsSameEntry(theEntry, i) then       								break true;       						end;       				end});       			 Print("soup cursor contains : "& theCurse:CountEntries());  //dbug LATER       			        			 //1.5 ADDED       			 local thePMCompMsg;       			 if myPrefs.exportPackManAd then       			 	begin       			 		if debugOn then print("exporting ad...");       			 		thePMCompMsg := PackManCompletionMessageScriptWithAd;       			 	end       			 else       			 	begin       			 		if debugOn then print("not exporting ad....");       					thePMCompMsg := PackManCompletionMessageScript;       				end;       				//END 1.5 ADDED       			 			        			getroot().|packman:ICS|:packman(       			   {       				   soupcursor:theCurse,   //this is the most important parameter       				   compander:"TLZStoreCompander", //optional       				   packagename:expPkgName, //name which will be given to the package         				   targetstore:getdefaultstore(), //store onto which package will be written       				   doinstall:true, //cause package to be installed after it is built       				   AutoDelete:true, //cause package to auto-delete itself after running       				   autoRun:true,  //cause package to auto-launch on install       				   description:"Dash Board scripts", //description of data in package       				   defaulttargetstore:'internal, //default installation store for contents of package       					entryvalidationscript: PackManEntryValScript, //see below       					completionmessagescript:thePMCompMsg, //see below       					inhibitStoreChange: NIL, //prevent user from changing target store for data in package       					additiveonly:true, //add entries to soup.  Do not give option to delete soup.       					partframeslots:{text: expPkgExtrasName} //text for extras drawer       			   }       			);       		       		local theNewAppSym := Intern(expPkgName);       		 AddDelayedCall(func() if GetRoot().(theNewAppSym) then getroot().(theNewAppSym):close(), nil, 2000);       			       			okCount := Length(theVictims); //to set status message properly on Packman export       	end;       		       		Print("OKCount is " & okCount);       		Print("Length(theVictims) is " & Length(theVictims));       		       	if okCount = Length(theVictims) then       		:SetHelp("The " & helpPhrase & " exported successfully.");        	else //set help to list error conditions.       		begin       			local errTotal := missingCount;       			local errTxt := :ScriptScripts(errTotal) && "could not be deleted." &&        				(if missingCount <> 0 then missingCount && "could not be found.");       			:SetHelp(errTxt);        		end;       		       	:RefreshList();       end;,     deathRow:       '[       	theHelp,       	theList,       ],     FileSelected:       func()       begin       	local theVictims := :GetSelectedItems();       	if not theVictims then       		begin       			:SysBeep();       			:SetHelp("There are no scripts currently selected. To select a script, tap the checkbox next to its name in the list.");       			return;       		end;       		       	local vCount := Length(theVictims);       	local vicName, helpPhrase;       	if vCount = 1 then       		begin       			local theVictim := ResolveEntryAlias(theVictims[0]);       			if theVictim = NIL then       				begin       					:SetHelp("The script could not be found! That means that a weird error occurred. Very sorry.");       					:RefreshList();       					return;       				end;       			vicName := "\"" & Clone(theVictim.name) & "\"script";       			helpPhrase := vicName && "was";       		end;       	else       		begin       			vicName := Length(theVictims) && "selected scripts";       			helpPhrase := vicName && "were";       		end;       		       		              	       	local fileText := "Select the store on which to file the" && vicName & ".";       	       	local tSize := 0; //real one LATER!       	       	fileSlip.text := fileText;       	fileSlip.caller := self;       	       	fileSlip:Open();       	       	       	       /*******************************************************       	local missingCount := 0;       	local lockedCount := 0;       	local okCount := 0;       	local uSOup := :GetScriptSoupRef();       	local dStore := GetDefaultStore();       	local tSoup := uSoup:GetMember(dStore);       	foreach i in theVictims do       		begin       			local theVic := ResolveEntryAlias(i);       			if theVic then       				begin       					if not dStore:IsReadOnly() then       						begin       							local theDupe := EntryCopyXmit(theVic, tSoup, kAppSymbol);       							theDupe.Name := theDupe.Name && "copy";       							EntryChangeXmit(theDupe, kAppSymbol);       							okCount := okCount + 1;       						end       					else       						lockedCount := lockedCount + 1;       				end       			else       				missingCount := missingCount + 1;       		end;       		       	if okCount = Length(theVictims) then       		:SetHelp("The " & helpPhrase & " duplicated successfully.");        	else //set help to list error conditions.       		begin       			:SysBeep();       			local errTotal := missingCount + lockedCount;       			local errTxt := :ScriptScripts(errTotal) && "(out of " & Length(theVictims) & ") could not be duplicated." &&        				(if missingCount <> 0 then missingCount && "could not be found.") &&       				(if lockedCount <> 0 then lockedCount &&  "could not be duplicated because the \"" & dStore:GetName() & "\" is write-protected.");       			:SetHelp(errTxt);        		end;       		       	theList:Effect(fxMoveH+fxHStartPhase+fxSteps(6)+fxStepTIme(8),nil, @380,'RefreshList,[]);  //change sound LATER?       	       	**********************************/              end;,     viewJustify: 240,     GetSelectedItems:       func() //returns array of script aliases, for deletion or filing       begin       	local selectees := [];       	foreach i in theList:ChildViewFrames() do       		begin       			if i.selected then       				AddArraySlot(selectees, i.myAlias);       		end;       		       	if Length(selectees) = 0 then       		selectees := NIL;       		       	return selectees;              end,     EditScript:       func(eAlias) //or NIL for new script       begin              	GetRoot().(kAppSymbol).scriptEditor.panelView := self;       	       	if eAlias then       		GetRoot().(kAppSymbol).scriptEditor.editee := ResolveEntryAlias(eAlias);       		       	GetRoot().(kAppSymbol).scriptEditor:Open();       end,     theHelp: nil,     DeleteScript:       func(theAlias)       begin       	local theVictim := ResolveEntryAlias(theAlias);       	local vicName := Clone(theVictim.name);              	if ModalConfirm("Are you sure you want to delete the \"" & vicName & "\" script? This operation is not undoable--the script will be lost.", ["Delete", "Cancel"]) = 0 then       		begin       			EntryRemoveFromSoupXmit(theVictim, kAppSymbol);       			:SetHelp("The \"" & vicName & "\" script was deleted successfully.");        			:RefreshList();       		end       	else       		:SetHelp("The Delete Script operation was cancelled.");       end,     viewClass: 74 /* clView */,     SelectAll:       func(theBool)       begin       	foreach i in theList:ChildViewFrames() do       		begin       			ProtoPerformIfDefined(i, 'DoSelect, [theBool]);       		end;       	       		       end    };helpText :=    {     text:       "The script panel allows you to create custom scripts, which can be run from the menu or from the Letter Launcher. (WARNING: This feature is for advanced users or developers only. It's possible to write scripts that can destroy your data or crash your machine.)"     ,     viewBounds: {left: 8, top: 8, right: -8, bottom: 58},     viewJustify: 48,     viewFlags: 3,     viewFormat: 131664,     viewFont: ROM_fontSystem9,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewbounds := SetBounds(8,8,-8, 46);       	else       		self.viewbounds := SetBounds(8,8,-8, 58);       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(scriptPanel, helpText);StepDeclare(scriptPanel, helpText, 'helpText);controlArea :=    {viewBounds: {left: 5, top: 67, right: 105, bottom: -5},     viewFlags: 1,     viewFormat: 0,     viewJustify: 192,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := lBounds       	else       		RemoveSlot(self, 'viewBounds);       	inherited:?ViewSetupFormScript();       end,     lBounds: SetBounds(5,55,133,-5),     viewClass: 74 /* clView */    };AddStepForm(scriptPanel, controlArea);StepDeclare(scriptPanel, controlArea, 'controlArea);controlArea_v0_0 :=    {     buttonClickScript:       func()       begin       	:parent():parent():EditScript(nil);       end,     viewBounds: {left: 0, top: 2, right: 96, bottom: 20},     myText: "New Script",     icon:       MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1308}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_0);controlArea_v0_1 :=    {     buttonClickScript:       func()       begin              	:DupeSelected();       end,     viewBounds: {left: 0, top: 28, right: 96, bottom: 46},     myText: "Duplicate",     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1303}),           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1303}),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1303}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_1);controlArea_v0_2 :=    {     buttonClickScript:       func()       begin       	:FileSelected();       end,     viewBounds: {left: 0, top: 132, right: 96, bottom: 150},     myText: "File",     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1305}),           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1305}),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1305}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_2);controlArea_v0_3 :=    {     buttonClickScript:       func()       begin       	:DeleteSelected();       end,     viewBounds: {left: 0, top: 158, right: 96, bottom: 176},     myText: "Delete",     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1304}),           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 1304}),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 1304}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_3);controlArea_v226_0 :=    {     buttonClickScript:       func()       begin       	:SelectAll(true)       end,     text: kCheckMarkChar & "All",     viewBounds: {left: -33, top: -15, right: -2, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(controlArea, controlArea_v226_0);controlArea_v226_0 :=    {     buttonClickScript:       func()       begin       	:SelectAll(nil)       end,     text: "      All",     viewBounds: {left: -73, top: -15, right: -42, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(controlArea, controlArea_v226_0);controlArea_v226_0_v204_0 :=    {indent: 0,     text: "",     viewBounds: {left: 2, top: -1, right: 17, bottom: 15},     viewFlags: 1,     _proto: @204 /* protoRCheckBox */    };AddStepForm(controlArea_v226_0, controlArea_v226_0_v204_0);controlArea_v0_6 :=    {viewBounds: {left: 0, top: 54, right: 96, bottom: 72},     buttonClickScript:       func()       begin       	local GL3Soup := GetUnionSoup("scripts:gesturelaunch3:ics");       	if not GL3Soup then       		popup := [{item: "No importable scripts found", pickable: NIL}];       	else       		begin       			popup := [];       			local c := GL3Soup:Query(NIL);       			local e := c:entry();       			local currItem;       			while e do        				begin       					currItem := {item: e.name, data: MakeEntryAlias(e)};       					AddArraySlot(popup, currItem);       					e:=c:next();       				end;       			Sort(popup, '|str<|, 'item);       			ArrayInsert(popup,{item: "GestureLaunch 3 Scripts:", pickable: NIL}, 0);       			ArrayInsert(popup, 'pickSeparator, 1);              		end;       		       		       		       		       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     text: "",     myText: "Import",     pickActionScript:       func(itemSelected)       begin       	local importEntry := ResolveEntryAlias(popup[itemSelected].data);       	RemoveSlot(self, 'popup);       	       	local idCheckHomey := SPrintObject(importEntry.id);       	if IsString(idCheckHomey) and EndsWith(idCheckHomey, ":ICS") then       		begin       			:Sysbeep();       			if ModalConfirm("NOTE: This script was written by ICS (http://www.newts.com) for use with GestureLaunch. You must be a registered user of" &&       				"GestureLaunch to import this script. If you are not a registered user of GestureLaunch, tap Cancel.", ["Cancel", "Proceed"]) = 0 then       				begin       					:RefreshList();       					:SetHelp("The Import operation was cancelled.");       					inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       					return NIL;       				end       		       		end;       	       	local mySoup := :GetScriptSoupRef();       	local importNote := "//NOTE: This script is an imported script written for \n" &       		"//use with GestureLaunch 3, from Innovative Computer \n" &       		"//Solutions. We're pleased to be able to offer \n" &       		"//Dash Board users the ability to import GestureLaunch 3 \n" &       		"//scripts for use with Dash Board.\n" &       		"\n//Many scripts can be imported and used immediately.\n" &       		"//However, not all GestureLaunch 3 scripts can be used\n" &       		"//with Dash Board. Scripts that rely on special\n" &       		"//features of GestureLaunch may need to be modified.\n" &       		"//In particular, if your GestureLaunch script relies on\n" &       		"//getting a parameter passed to it (\"parm\"), then you\n" &       		"//may need to add code to set the parm variable to a\n" &       		"//suitable value. (In Dash Board parm is set to NIL\n" &       		"//by default.)\n" &       		"\n//For more information, please consult the Dash Board\n" &       		"//manual.\n";       	       	local importNote2 := ""; //change to parm code if necessary.       		       	local impScript := Clone(importEntry.script);       	       	if debugOn then       		begin       			Print("HERE IS PRE-IMPORT SCRIPT:");       			Print(impScript);       		end;       	       	TrimString(impScript);       	       	if BeginsWith(impScript, "begin") then       		begin       			if EndsWith(impScript, "end;") then       				begin       					if debugOn then Print("imported script begins with begin and ends with end;");       					StrMunger(impScript, 0, 5, "", 0, NIL);       					StrMunger(impScript, StrLen(impScript) - 5, NIL, "", 0, NIL);       				end       			else if EndsWith(impScript, "end") then       				begin       					if debugOn then Print("imported script begins with begin and ends with end");       					StrMunger(impScript, 0, 5, "", 0, NIL);       					StrMunger(impScript, StrLen(impScript) - 4, NIL, "", 0, NIL);       				end;       		end;       	       	if debugOn then       		begin       			Print("HERE IS POST-IMPORT SCRIPT:");       			Print(impScript);       		end;       	       		       	//now check for GL3-specific features.       	local GLMethods :=        		[       			"cmdkey", "doOpen", "do_Configure_For", "flash_letter", "GetPartEntryFromAppFrame",       			"GLaunchActionFunc", "GlaunchGetConfig", "GLaunchGetScript", "GLaunchGetScriptFunc",       			"GLaunchGetTag", "GLaunchPassScript", "GLaunchRunScript", "LaunchPartEntry"       		];       		       	local GLMethodsFound := [];       		       	foreach i in GLMethods do       		begin       			if StrPos(impScript, i, 0) then       				AddArraySlot(GLMethodsFound, i & "()");       		end;       	       	local impWarnings := "\n//SCRIPT IMPORT NOTES & WARNINGS:\n";       	       	if StrPos(impScript, "parm", 0) then       		begin       			impWarnings := impWarnings & "//PARAMETER WARNING: This imported script\n" &       				"//     appears to use the GestureLaunch \"parm\"\n" &       				"//     parameter. Dash Board does not pass a parameter\n" &       				"//     to its scripts, so you may need to add code to get a\n" &       				"//     suitable value for the parm variable.\n";       			importNote2 := "\n\nparm := NIL; //change this if necessary.\n\n";       		end;       		       	foreach i in GLMethodsFound do       		begin       			impWarnings := impWarnings & "//POSSIBLE UNSUPPORTED GL3 METHOD:" && i & "\n";       		end;       		       	if StrPos(impScript, "parm", 0) = NIL and Length(GLMethodsFound) = 0 then       		impWarnings := impWarnings & "//no problems detected\n";       	       	local impComments := importNote & impWarnings & importNote2;       	       	local importFrame :=        		{       			name: importEntry.name,       			scriptText: impComments & impScript & "\n\n",       			date: TimeInSeconds(),       			info: importEntry.description,       			id: importEntry.id       			       		};       		       	mySoup:AddToDefaultSToreXmit(importFrame, kAppSymbol);       	:RefreshList();       	:SetHelp("The script " & Clone(importEntry.name) & " was imported successfully.");       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	RemoveSlot(self, 'popup);       		:setHelp("No script was imported.");       	inherited:?PickCancelledScript();		// this method is defined internally       end,     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 6666}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 6666}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_6);controlArea_v0_7 :=    {viewBounds: {left: 0, top: 106, right: 96, bottom: 124},     buttonClickScript:       func()       begin       	popup := MakeFontMenu(myPrefs.scriptFont, 'all,nil,'none);              		       		       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     text: "",     myText: "Set Font",     pickActionScript:       func(itemSelected)       begin       	local theMsg :=  "Hmm. Weird.";       	if hasSlot(popup[itemselected], 'family) then       		begin       			myPrefs.scriptFont.family := popup[itemselected].family;       			theMsg := "The script editor font was changed to " & popup[itemselected].item & ".";       		end       	else if HasSlot(popup[itemselected], 'size) then       		begin       			myPrefs.scriptFont.size := popup[itemselected].size;       			theMsg := "The script editor font size was changed to " & popup[itemselected].item & ".";       		end;	       	RemoveSlot(self, 'popup);       	:setHelp(theMsg);       	       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     pickCancelledScript:       func()       begin       	RemoveSlot(self, 'popup);       		:setHelp("The script editor font was not changed.");       	inherited:?PickCancelledScript();		// this method is defined internally       end,     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 156}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_7);controlArea_v0_8 :=    {viewBounds: {left: 0, top: 80, right: 96, bottom: 98},     buttonClickScript:       func()       begin              	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     text: "",     myText: "Export",     pickCancelledScript:       func()       begin       	RemoveSlot(self, 'popup);       		:setHelp("No script was exported.");       	inherited:?PickCancelledScript();		// this method is defined internally       end,     icon:       begin           local r := MakePixFamily(           GetResourceFromFile({filename:                 "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc",                 resource: 157}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 157}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00E72020", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     pickActionScript:       func(itemSelected)       begin       	:ExportSelected(popup[itemSelected].exportType);       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     popup:       [       	{item: "Export To Notes", exportType: 'notes},       	{item: "Export To New Package", exportType: 'packMan}       ],     _proto: coolBtn    };AddStepForm(controlArea, controlArea_v0_8);contentHolder :=    {viewBounds: {left: 110, top: 67, right: -5, bottom: -5},     viewFlags: 1,     viewFormat: 0,     viewJustify: 240,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if GetRoot().(kAppSymbol).landscapeMode then       		self.viewBounds := lBounds;       	else       		RemoveSlot(self, 'viewBounds);       	inherited:?ViewSetupFormScript();       end,     lBounds: SetBounds(136,55,-5,-5),     viewSetupDoneScript:       func()       begin       		if theList.scrolling then       			scroller:show()       		else       			scroller:hide();       		       		theList.scrollSafe := true;       end,     viewClass: 74 /* clView */    };AddStepForm(scriptPanel, contentHolder);StepDeclare(scriptPanel, contentHolder, 'contentHolder);scriptHolder :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewFlags: 33,     viewFormat: 592,     viewJustify: 240,     viewSetupDoneScript:       func()       begin       	theList := self;       end,     index: 0,     ViewScroll2DScript:       func(dir, extras)       begin       	if dir = 'up then       		begin       			if index = 0 then       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					index := index - 1;       					//:RedoChildren();       					:setOrigin(0, index * 13);       				end;       		end       	else       		begin       			if (total - index) <= myFit then //then no more scroll down       				begin       					if not extras.stopped then       						begin       							extras.stopped := true;       							scroller:PlayStopSound();       						end;       				end       			else       				begin       					index := index + 1;       					:setOrigin(0, index * 13);       					//:RedoChildren();       				end;       		end;       	       	:RefreshArrows();       	RefreshViews();       end;,     viewSetupChildrenScript:       func()       begin              	RemoveSlot(self, 'stepchildren);       	self.stepChildren := Clone(self.stepchildren);       	local theIndex := index;       	       	nameWidth := :LocalBox().right - :LocalBox().left - 70 ; //width to truncate names to       	local uSoup := :GetScriptSoupRef();       	local theCursor := uSoup:Query({indexpath: ['name, 'date]});       	local theEntry := theCursor:Entry();       	total :=  theCursor:CountEntries();       	       	while theEntry do       		begin       			local theItem :=  {_proto: GetLayout("scriptItem.proto")};       			theItem.myAlias := MakeENtryAlias(theEntry);       			theItem.myTitle := Clone(theEntry.name);       			theItem.storeText := Clone(EntryStore(theEntry):GetName());       			AddArraySlot(self.stepChildren, theItem);       			theEntry := theCursor:Next();       		end;       		       	       	       	if Length(self.stepChildren) = 2 then       		emptyMsg:Open();       	else       		AddDeferredSend( emptyMsg, 'Close, nil);       	       	myFIt := (:LocalBox().bottom - :LocalBox().top) div 13;       	       	if Length(self.StepChildren) - 2 > myFit then        		self.scrolling := true       	else       		self.scrolling := nil;       		       	       if scrollSafe then //should be NIL on first setup, and true after that       	begin       		if scrolling then        			begin       				Scroller:Show();       				AddDeferredSend(scroller, 'MoveBehind, [nil]);       				AddDeferredSend(self, 'RefreshArrows, nil);       			end       		else       			Scroller:Hide();       	end;              		       	currentSelection := NIL;       end,     RefreshArrows:       func()       begin       	if index > 0 then       		scroller:SetArrow('up, 'more);       	else       		scroller:SetArrow('up, 'normal);       		       	if total - index > myFit then       		scroller:SetArrow('down, 'more);       	else       		scroller:setArrow('down, 'normal);       end,     myFit: nil,     total: 0,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	foreach i in deathRow do       		RemoveSlot(self, i);       	inherited:?ViewQuitScript();       end,     deathRow:       '[       	index,       	myFit,       	total,       	stepChildren,       	scrolling,       	scrollSafe       ],     nameWidth: 0,     scrolling: nil,     scrollSafe:       nil  //when we first launch we must not update scroller in viewsetupchildren(), but after we should. so set this on 1st setup to true as flag       ,     viewClass: 74 /* clView */    };AddStepForm(contentHolder, scriptHolder);StepDeclare(contentHolder, scriptHolder, 'scriptHolder);emptyMsg :=    {     text:       "There are no scripts defined. Tap the New Script button to create one.",     viewBounds: {left: 0, top: 0, right: 160, bottom: 120},     viewFont: ROM_fontSystem10Bold,     viewFlags: 2,     viewJustify: 86,     _proto: @218 /* protoStaticText */    };AddStepForm(scriptHolder, emptyMsg);StepDeclare(scriptHolder, emptyMsg, 'emptyMsg);aligner :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 0,     viewJustify: 48,     viewClass: 74 /* clView */    };AddStepForm(scriptHolder, aligner);scroller :=    {viewFlags: 65,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	scrollview := scriptHolder;       	inherited:?ViewSetupFormScript();       end,     viewSetupDoneScript:       func()       begin       	scriptHolder:RefreshArrows();       end,     ViewScroll2DScript:       func(direction,extras)       begin       	Inherited:?ViewScroll2DScript(direction,extras);       end,     _proto: @656 /* protoUpDownScroller */    };AddStepForm(contentHolder, scroller);StepDeclare(contentHolder, scroller, 'scroller);constant |layout_scriptPanel.t| := scriptPanel;// End of file scriptPanel.t// Beginning of file miscPanel.tmiscPanel :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 0,     viewFormat: 1,     viewJustify: 240,     viewClass: 74 /* clView */    };miscPanel_v74_0 :=    {viewBounds: {left: 8, top: 8, right: 312, bottom: 24},     viewFlags: 1,     viewFormat: 0,     viewClass: 74 /* clView */    };AddStepForm(miscPanel, miscPanel_v74_0);miscPanel_v74_0_v218_0 :=    {text: "Newton Menu:",     viewBounds: {left: 0, top: 0, right: 304, bottom: 16},     viewJustify: 8388616     ,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel_v74_0, miscPanel_v74_0_v218_0);miscPanel_v74_0 :=    {viewBounds: {left: 8, top: 24, right: 312, bottom: 40},     viewFlags: 1,     viewFormat: 0,     viewClass: 74 /* clView */    };AddStepForm(miscPanel, miscPanel_v74_0);miscPanel_v74_0_v164_0 :=    {text: "Separate mini-buttons for Running and Recent app menus",     viewBounds: {left: 0, top: 0, right: 304, bottom: 16},     viewSetupFormScript:       func()       begin       	viewvalue := myPrefs.triBtn;       	inherited:?viewSetupFormScript();       end,     valueChanged:       func()       begin       	myPrefs.triBtn := viewValue;        end,     _proto: @164 /* protoCheckBox */    };AddStepForm(miscPanel_v74_0, miscPanel_v74_0_v164_0);miscPanel_v218_0 :=    {text: "By default, use large custom icons in:",     viewBounds: {left: 8, top: 40, right: 312, bottom: 56},     viewJustify: 8388616,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel, miscPanel_v218_0);iLvlRBtns :=    {viewBounds: {left: 8, top: 56, right: 312, bottom: 104},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	clustervalue := myPrefs.iLvl;       	inherited:?ViewSetupFormScript();       end,     clusterChanged:       func()       begin       	myPrefs.iLvl := clustervalue;       end,     _proto: @203 /* protoRadioCluster */    };AddStepForm(miscPanel, iLvlRBtns);iLvlRBtns_v202_0 :=    {buttonValue: 0,     viewBounds: {left: 0, top: 0, right: 296, bottom: 18},     text: "Running Apps and Recent Apps menus/submenus only",     _proto: @202 /* protoRadioButton */    };AddStepForm(iLvlRBtns, iLvlRBtns_v202_0);iLvlRBtns_v202_0 :=    {buttonValue: 1,     viewBounds: {left: 0, top: 15, right: 296, bottom: 33},     text: "Running Apps and Recent Apps menus, and all submenus",     _proto: @202 /* protoRadioButton */    };AddStepForm(iLvlRBtns, iLvlRBtns_v202_0);iLvlRBtns_v202_0 :=    {buttonValue: 2,     viewBounds: {left: 0, top: 30, right: 296, bottom: 48},     text: "All menus & submenus, including the Newton Menu",     _proto: @202 /* protoRadioButton */    };AddStepForm(iLvlRBtns, iLvlRBtns_v202_0);miscPanel_v74_0 :=    {viewBounds: {left: 8, top: 104, right: 312, bottom: 120},     viewFlags: 1,     viewFormat: 0,     viewClass: 74 /* clView */    };AddStepForm(miscPanel, miscPanel_v74_0);miscPanel_v74_0_v218_0 :=    {text: "Backlight:",     viewBounds: {left: 0, top: 0, right: 304, bottom: 16},     viewJustify: 8388616     ,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel_v74_0, miscPanel_v74_0_v218_0);blotStuff :=    {viewBounds: {left: 8, top: 120, right: 312, bottom: 136},     viewFlags: 1,     viewFormat: 0,     viewSetupDoneScript:       func()       begin       	if not myPrefs.blot then blotchBox:Close();       end,     viewClass: 74 /* clView */    };AddStepForm(miscPanel, blotStuff);blotBox :=    {     text:       "Any tap on Dash Board turns it on       ",     viewBounds: {left: 0, top: 0, right: 168, bottom: 16},     valueChanged:       func()       begin       	myPrefs.blot := viewvalue;       	if viewValue then       		blotchBox:Open();       	else       		blotchBox:Close();       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	viewValue := myPrefs.blot;       	inherited:?ViewSetupFormScript();       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(blotStuff, blotBox);StepDeclare(blotStuff, blotBox, 'blotBox);blotchBox :=    {text: "continue processing tap",     viewBounds: {left: 168, top: 0, right: 304, bottom: 16},     valueChanged:       func()       begin       	myPrefs.blotch := viewValue;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if debugOn then print("Blotch box should be:");       	if debugOn then print(myPrefs.blotch);       	       	viewValue := myPrefs.blotch;       	inherited:?ViewSetupFormScript();       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(blotStuff, blotchBox);StepDeclare(blotStuff, blotchBox, 'blotchBox);miscPanel_v218_0 :=    {text: "Recent Apps:",     viewBounds: {left: 8, top: 136, right: 304, bottom: 152},     viewJustify: 8388616,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel, miscPanel_v218_0);miscPanel_v164_0 :=    {text: "Track recently-used apps even if not launched from Dash Board",     viewBounds: {left: 8, top: 152, right: 304, bottom: 168},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	viewValue := myPrefs.recPatch;       	inherited:?ViewSetupFormScript();       end,     valueChanged:       func()       begin       	myPrefs.recPatch := viewValue;       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(miscPanel, miscPanel_v164_0);miscPanel_v218_0 :=    {text: "Frozen Apps:",     viewBounds: {left: 8, top: 184, right: 304, bottom: 200},     viewJustify: 8388616,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel, miscPanel_v218_0);miscPanel_v190_0 :=    {     labelCommands:       [       "5",       "8",       "10",       "12",       "15",       "18",       "20",       "25"       ],     text: " Number of recently-used apps to show in menu:",     viewBounds: {left: 9, top: 169, right: 303, bottom: 183},     alwaysCallPickActionScript: true,     viewFont: ROM_fontSystem9,     labelActionScript:       func(cmd)       begin       	myPrefs.recentNum := Floor(StringToNumber(labelCommands[cmd]));       end,     textSetup:       func() // return first one as default       begin       	return NumberStr(myPrefs.recentNum);       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	entryline.viewFont := ROM_FontSystem10Bold;       	inherited:?ViewSetupFormScript();       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(miscPanel, miscPanel_v190_0);freezeSHiot :=    {viewBounds: {left: 8, top: 200, right: 304, bottom: 232},     viewFlags: 1,     viewFormat: 0,     viewSetupDoneScript:       func()       begin       	if myPrefs.launchFrozen then        		refreezeBox:Open()       	else       		refreezeBox:Close();       end,     viewClass: 74 /* clView */    };AddStepForm(miscPanel, freezeSHiot);freezeSHiot_v164_0 :=    {text: "When a frozen app is chosen from a menu, launch it after thawing",     viewBounds: {left: 0, top: -1, right: 296, bottom: 15},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	viewValue := myPrefs.launchFrozen;       	inherited:?ViewSetupFormScript();       end,     valueChanged:       func()       begin       	myPrefs.launchFrozen := viewValue;       	if viewValue then        		refreezeBox:Open()       	else       		refreezeBox:Close();       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(freezeSHiot, freezeSHiot_v164_0);refreezeBox :=    {text: "and refreeze it after it is closed",     viewBounds: {left: 25, top: 14, right: 296, bottom: 30},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	viewValue := myPrefs.rf;       	inherited:?ViewSetupFormScript();       end,     valueChanged:       func()       begin       	myPrefs.rf := viewValue;       end,     viewFlags: 512,     _proto: @164 /* protoCheckBox */    };AddStepForm(freezeSHiot, refreezeBox);StepDeclare(freezeSHiot, refreezeBox, 'refreezeBox);miscPanel_v218_0 :=    {text: "Time Button:",     viewBounds: {left: 8, top: 228, right: 304, bottom: 244},     viewJustify: 8388616,     _proto: @218 /* protoStaticText */    };AddStepForm(miscPanel, miscPanel_v218_0);timeBtnOpts :=    {     labelCommands:       [       	"Dash Board Time Display",       	"Newton Clock"       ],     text: " Tapping time button opens:",     viewBounds: {left: 9, top: 244, right: 303, bottom: 258},     alwaysCallPickActionScript: true,     viewFont: ROM_fontSystem9,     labelActionScript:       func(cmd)       begin       		myPrefs.noDBTD := if cmd = 0 then NIL else TRUE;       end,     textSetup:       func() // return first one as default       begin       	if myPrefs.noDBTD then       		"Newton Clock"       	else       		"Dash Board Time Display";       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	entryline.viewFont := ROM_FontSystem10Bold;       	inherited:?ViewSetupFormScript();       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(miscPanel, timeBtnOpts);constant |layout_miscPanel.t| := miscPanel;// End of file miscPanel.t// Beginning of file main.tDashBoardPrefs :=    {     ScriptScripts:       func(x)       begin       	if x = 1 then "script" else "scripts";       end,     ByteSize:       func(numBytes)       begin	       	local theText;       	if numBytes > 1048576 then       			theText := (numBytes div 1048576) & "." & (((numBytes mod 1048576) div 1024) div 100) & "MB";       		else       			theText := (numBytes div 1024) & "K";       	return theText;              end,     viewSetupDoneScript:       func()       begin       	if not GetRoot().(kAppSymbol).myPrefs.DBInited then  //die if no dash board prefs       		begin       			:Notify(kNotifyAlert, "Dash Board Prefs", "Dash Board Prefs cannot run until Dash Board has been installed.\n\n Please install Dash Board, and try again.");       			local pEntry := GetAppPrefs('|DashBoard:FiveSpeed|, {initialized: NIL});       			if not pEntry.initialized then EntryRemoveFromSoupXmit(pEntry, kAppSYmbol);       			GetRoot():LockScreen(true);       			AddDeferredSend(self, 'Close, nil);       		end;       	else if not GetRoot().|DashBoard:FiveSpeed| then       		begin       			:Notify(kNotifyAlert, "Dash Board Prefs", "Dash Board is not currently installed. Dash Board must be installed on the Newton device before you can edit its preferences.\n\n Please install Dash Board, and try again.");       			GetRoot():LockScreen(true);       			AddDeferredSend(self, 'Close, nil);       		end       	       	else //else ok to run!       		begin       			Pane2.panelHolder.newtMenuPanel:Open();       		end;       end,     GetSpecialsList:       func(sepOrNot)       begin       	local sPopup := [];       	foreach i in GetRoot().|DashBoard:FiveSpeed|.db_SpecialItems do       		begin       			AddArraySlot(sPopup, {item: i.text, icon: GetRoot().|DashBoard:FiveSpeed|.(i.icon), indent: 18, data: i});       		end;       		       	if sepOrNot then       		AddArraySlot(sPopup, {item: "Menu Separator", icon: iSeparator, data: {type: 'separator, text: "", submenu: NIL, data: nil, icon: 'iNone}});              	return Sort(sPopup, '|str<|, 'item);       end,     viewFormat: 1,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	       	:DeathPenalty();       	inherited:?ViewQuitScript();       end,     PackManCompletionMessageScriptWithAd:       func(app)  //this is Dan Rowley's version plus our ad for PackMan--only used if DBP's exportpackManAd hidden pref is true (i.e., five speed only)       begin              if not GetRoot().|PackMan:ICS| then       	begin       		GetRoot():Notify(kNotifyQAlert, "Message from Five Speed", "You can export your own custom scripts to an installer like this one with PackMan from ICS! \n See their web site at www.newts.com for more info.");       	end;       	        getroot():notify(kNotifyAlert,"Script Install       Complete",""&app.newcount&&"new"&&(if app.newcount=1 then "script was" else       "scripts were")&&                 "added, "&app.updatecount&&(if app.updatecount=1 then "script was"       else "scripts were")&&"updated to new versions, and "&&                 app.skipcount&&(if app.skipcount=1 then "was" else       "were")&&"skipped because they already existed.");        removeslot(app,'newcount);        removeslot(app,'skipcount);        removeslot(app,'updatecount);       end,     viewFlags: 517,     LoadPrefs:       func()       begin       	GetRoot().(kAppSymbol).myPrefs := {};       	       	local dbPrefs := GetAppPrefs('|DashBoard:FiveSpeed|, {initialized: NIL});       	       	if not dbPrefs.initialized then       		begin       			if getRoot().|DashBoard:FiveSpeed| then       				getRoot().|DashBoard:FiveSpeed|:CreateDefaultPrefs();       		end;       				       	dbPrefs := GetAppPrefs('|DashBoard:FiveSpeed|, {initialized: NIL});       	       	if dbPrefs.initialized and GetRoot().(kDBSym) then       		begin       			//GET CLONES OF DB's PREFS -- CLONE SLOT BY SLOT CUZ SOME SLOTS ARE USED ONLY BY DB ITSELF       			GetRoot().(kAppSymbol).myPrefs.nMenu := DeepClone(GetRoot().|DashBoard:FiveSpeed|:DB_GetNMenuData().nMenu);        			GetRoot().(kAppSymbol).myPrefs.LLCmds := DeepClone(GetRoot().|DashBoard:FiveSpeed|:DB_GetLLData().LLData);       			Sort(GetRoot().(kAppSymbol).myPrefs.LLCmds, '|str<|, 'name);       			myPrefs.triBtn := dbPrefs.triBtn;       			myPrefs.iLvl := dbPrefs.iLvl;       			myPrefs.blot := dbPrefs.blot;       			myPrefs.blotch := dbPrefs.blotch;       			myPrefs.rf := dbPrefs.rf;       			myPrefs.recPatch := dbPrefs.recPatch;       			myPrefs.recentNum := dbPrefs.recentNum;       			myPrefs.launchFrozen := dbPrefs.launchFrozen;       			myPrefs.scriptFont := dbPrefs.scriptFont;       			myPrefs.noDBTD := dbPrefs.noDBTD       		end;       	       	GetRoot().(kAppSymbol).myPrefs.DBInited := dbPrefs.initialized; //quit from viewSetupDoneScript if not       end,     viewBounds: {left: 0, top: 0, right: 320, bottom: 434},     _proto: @157 /* protoApp */,     landscapeMode: nil,     ValidatePrefs:       func()       begin       	modalator:OPen();       	validator:Open();       end,     viewScrollDownScript:       func()       begin       	:SysBeep();       end,     viewOverviewScript:       func()       begin       	:SysBeep();       end,     deathRow:       // array of syms corresponding to slots to remove at quit time       '[       	viewBounds,       	landscapeMode,       	myPrefs,       	validationBadCount,       	validationNumChecked,       	validationNumSkipped,       	validationNumRemoved,       	validationNumReassigned,       	abortValidation,       	validationRemAll,       	expPkgName,       	PackManNameSlip,       	expPkgExtrasName       ],     viewJustify: 80,     title: kAppName,     GetScriptList:       func()  //must retrun NIL if no scripts exist       begin	       	local uSoup := :GetScriptSoupRef();       	local theCursor := uSoup:Query({indexpath: ['name, 'date]});       	local theEntry := theCursor:Entry();       	local thePopup := [];       	       	if theCursor:CountEntries() = 0 then return NIL;       	       	//otherwise...       	       	while theEntry do        		begin       			AddArraySlot(thePopup, {item: CLone(theEntry.name), icon: GetRoot().|DashBoard:FiveSpeed|.iScript, indent: 18, data: MakeENtryAlias(theEntry)});       			theEntry := theCursor:Next();       		end;       	return thePopup;        end,     DeathPenalty:       func()       begin       	foreach i in self.deathRow do       		begin       			if IsFrame(i) then       				begin       					if i.viewCobject then i:Close();       				end;       			RemoveSlot(self, i);       		end;       end,     viewScrollUpScript:       func()       begin       	:SysBeep();       end,     PackManCompletionMessageScript:       func(app)  //this is Dan Rowley's version       begin        getroot():notify(kNotifyAlert,"Script Install       Complete",""&app.newcount&&"new"&&(if app.newcount=1 then "script was" else       "scripts were")&&                 "added, "&app.updatecount&&(if app.updatecount=1 then "script was"       else "scripts were")&&"updated to new versions, and "&&                 app.skipcount&&(if app.skipcount=1 then "was" else       "were")&&"skipped because they already existed.");        removeslot(app,'newcount);        removeslot(app,'skipcount);        removeslot(app,'updatecount);       end,     GetRuntimeIcon:       func(theALias) //MODIFIED 990226 TO TRACK THE FUCKING SNOWFLAKE ICON FOR BUILTIN APPS PROB       begin       	if debugOn then       		begin       			local sTicks := Ticks();       			print("calling GetRuntimeIcon()....");       		end;       		       	       	       	local e := ResolveEntryAlias(theAlias);       	local theResult;       	       	//PRINT(e);       	       	if e then       		begin       		       			if e.Class and (e.Class = 'ROMFormEntry or e.Class = 'ROMScriptEntry) then  //THIS LINE ADDED 990226 to fix SNOWFLAKE ICON PROBLEM       				theResult := GetRoot().(kDBSym).iPackage;       				       			else if not IsPackageActive(GetPkgRef(e.PackageName, EntryStore(e))) then       					theResult := GetRoot().(kDBSym).iSnowflake       			else if (e.class = 'BookEntry) or (e.class = 'HelpBookEntry) then       				theResult := GetRoot().(kDBSym).iBook       			else if (e.class = 'AutoEntry) or (e.class = '|????Entry|) then       				theResult := GetRoot().(kDBSym).iCube       			else       				theResult := GetRoot().(kDBSym).iPackage;       		end       	else       		theResult := GetRoot().(kDBSym).iQ;  //return ? icon if alias not resolved.       		       	if debugOn then       		begin       			local eTicks := Ticks();       			Print(eTicks - sTicks);       			print("result is:");       			print(theResult);       		end;              	return theResult;       end       ,     declareSelf: 'base,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.viewbounds := GetAppParams().appAreaBounds;              	       	if self.viewbounds.right > self.viewbounds.bottom then //landscape orientation       		self.landscapeMode := true       	else       		self.landscapeMode := NIL;       		       		       	:LoadPrefs();              	inherited:?ViewSetupFormScript();	       end,     ExportPrefsToDB:       func()       begin       	local dbPrefs := GetAppPrefs('|DashBoard:FiveSpeed|, {initialized: NIL}); //get dashboard's prefs frame       	       	//SAVE NMENU DATA       	local nMenuPrefs := GetRoot().|DashBoard:FiveSpeed|:DB_GetNMenuData();       	nMenuPrefs.nMenu := DeepClone(GetRoot().(kAppSymbol).myPrefs.nMenu);  //export new nMenu prefs to DashBoard       	EntryChangeXmit(nMenuPrefs, kAppSymbol);       	       	//SAVE LL DATA       	local LLPrefs := GetRoot().|DashBoard:FiveSpeed|:DB_GetLLData();       	LLPrefs.LLData := DeepClone(GetRoot().(kAppSymbol).myPrefs.LLCmds);       	EntryChangeXmit(LLPrefs, kAppSymbol);              	//export other prefs below       	dbPrefs.triBtn := myPrefs.triBtn;       	dbPrefs.iLvl := myPrefs.iLvl;       	dbPrefs.blot := myPrefs.blot;       	dbPrefs.blotch := myPrefs.blotch;       	dbPrefs.rf := myPrefs.rf;       	dbPrefs.recPatch := myPrefs.recPatch;       	dbPrefs.recentNum := myPrefs.recentNum;       	dbPrefs.launchFrozen := myPrefs.launchFrozen;       	dbPrefs.scriptFont := myPrefs.scriptFont;       	dbPrefs.noDBTD := myPrefs.noDBTD;       	       	EntryChangeXmit(dbPrefs, kAppSymbol);              	if GetRoot().|DashBoard:FiveSpeed| then       		begin       			:LockScreen(true);       			GetRoot().|DashBoard:FiveSpeed|:Close();       			GetRoot().|DashBoard:FiveSpeed|:Open();       			RefreshViews();       			:LockScreen(NIL);       		end;                     end,     GetSortedPkgList:       func()  //returns list of ACTIVE part entries       begin       	local pkgList := [];       	local theCurse := GetRoot().ExtrasDrawer:GetPartCursor(nil,nil,'_all);       	local theEntry := theCurse:Entry();       	local skipMe := NIL;       	       	while theEntry do       		begin       			skipMe := NIL;       			local theIcon := 'iPackage;       			if theEntry.class = 'frozenEntry then        				skipMe := true       			else if (theEntry.class = 'bookEntry) or (theEntry.class = 'helpBookENtry) then        				theIcon := 'iBook       			else if (theEntry.class = 'AutoEntry) or (theEntry.class = '|????Entry|) then       				theIcon := 'iCube;       		       			if not SetContains(theENtry._taglist, '_extensions) and not skipMe then       				AddArraySlot(pkgList, {item: Clone(theEntry.text), icon: GetRoot().|DashBoard:FiveSpeed|.(theIcon), indent: 18, data: MakeEntryAlias(theEntry)});       			theEntry:=theCurse:Next();       		end;       		       	theCurse := GetRoot().ExtrasDrawer:GetPartCursor(nil,nil,'_buttonBar);       	theEntry := theCurse:Entry();       	       	while theEntry do       		begin       			skipMe := NIL;       			local theIcon := 'iPackage;       			if theEntry.class = 'frozenEntry then        				skipMe := true       			else if (theEntry.class = 'bookEntry) or (theEntry.class = 'helpBookENtry) then        				theIcon := 'iBook       			else if (theEntry.class = 'AutoEntry) or (theEntry.class = '|????Entry|) then       				theIcon := 'iCube;       			if not skipMe then       				AddArraySlot(pkgList, {item: Clone(theEntry.text), icon: GetRoot().|DashBoard:FiveSpeed|.(theIcon), indent: 18, data: MakeEntryAlias(theEntry)});       			theEntry:=theCurse:Next();       		end;       		       	return Sort(pkgList, '|str<|, 'item);              end,     GoToPanel:       func(theSym) //'menu, 'launcher, 'scripts, or 'misc       begin       	if theSym = 'launcher then       		Pane2.letterLauncherTab:TabActivate();              	//only luancher panel is used for now...       end,     SinglePlural:       func(howMany, theSingular, thePlural, sVerb, pVerb)  //makes plural subject verb pharase       begin       	if howMany = 1 then       		return howMany && theSingular & (if sVerb then " " & sVerb)       	else       		return howMany && thePlural & (if pVerb then " " & pVerb);       end,     GetHelpStr:       func(theSym, theText, theType) //data sym, text name, & type of cmd item or dynsub item. This func returns a help string       begin       	local symArray :=       		[       			'dynRunning,       			'dynScripts,       			'dynRecent,       			'dynExtras,       			'dynSpecials,       			'dynMI,       			'cmd61,       			'cmdAlignPen,       			'cmdAbout,       			'cmdConnect,       			'cmdGuestModeOn,       			'cmdGuestModeOff,       			'cmdKbd1,       			'cmdKbd2,       			'cmdKbd3,       			'cmdKbd4,       			'cmdMIAAG,       			'cmdMICall,       			'cmdMIEvent,       			'cmdMIMtg,       			'cmdMITodo,       			'cmdNewCall,       			'cmdNewChecklist,       			'cmdNewNote,       			'cmdNewOutline,       			'cmdNewRec,       			'cmdReboot,       			'cmdWhoWhere,       			'cmdLLHelp,       			'cmdSleep,       			'cmdQuit,       			'cmdPrefs,       			'cmdToggleBB,       			'dynBooks       			       		];       	       	local typeStr := "Unknown Menu Item";       	if theType = 'dynsub then       		typeStr := "Special Submenu"       	else if theType = 'cmd then       		typeStr := "Special Item";       				       	local stringArray :=        		[       			"will display a submenu of currently running applications.",       			"will display a submenu containing all currently installed Dash Board user scripts.",       			"will display a submenu containing a list of recently-used programs.",       			"will display a submenu containing a list folders available in the Extras Drawer. Each folder submenu will display the contents of the corresponding Extras Drawer folder.",       			"will display a submenu containing a list of all of Dash Board's Special Items. (You'll probably want to make a custom submenu containing only the ones you use.)",       			"will display a submenu containing Dash Board's Special Items for working with MoreInfo from SilverWARE.",       			"will rebuild the package cache, which can help alleviate symptoms of the notorious -10061 error, caused by a Newton OS bug.",       			"will allow you to set the Newton device's pen alignement.",       			"will display information about this version of Dash Board.",       			"will open the Dock application and automatically try to connect, using the default connection settings.",       			"will set the Newton device's handwriting recognition to guest mode (so you can let others write without affecting your personal recognition settings).",       			"will turn off handwriting recognition guest user mode (if it was on).",       			"will open the built-in typewriter keyboard.",       			"will open the built-in numeric keyboard.",       			"will open the built-in telephone keyboard.",       			"will open the built-in dates keyboard.",       			"will open the MoreInfo At-A-Glance application.",       			"will create a new Call using MoreInfo.",       			"will create a new Event using MoreInfo.",       			"will create a new Meeting using MoreInfo.",       			"will create a new To Do task using MoreInfo.",       			"will create a new Call using the built-in Calls program.",       			"will open the built-in Notes program and create a new checklist note.",       			"will open the built-in Notes program and create a new note.",       			"will open the built-in Notes program and create a new outline note.",       			"will open the built-in Notes program, create a new audio recording note, and begin recording automatically.",       			"will reset the Newton device.",       			"will pop up a slip that allows you to quickly change the current location and owner settings.",       			"will display a list of currently defined Letter Launcher shortcuts.",       			"will put the Newton device to sleep (power off).",       			"will close Dash Board, restoring the built-in system button bar.",       			"will open the Dash Board Prefs program, allowing you to configure Dash Board.",       			"will toggle the button bar (i.e., show it if it is hidden, or hide it if it is visible).",       			"will display a submenu containing your currently installed Newton Books."              			];       		       	local theIndex := LSearch(symArray, theSym, 0, '|=|, NIL);       	       	if not theIndex then       		return "Oh no! No help is available for this item. This is a bug; please report it to Five Speed Software and we'll fix it."       	else       		return ParamStr(kMenuItemHelpStr, [typeStr, theText, stringArray[theIndex]]);       end,     FSNotify:       func(theMsg)       begin       	:Notify(kNotifyAlert, kAppName, theMsg);       end,     viewSetupChildrenScript:       func()       begin       	if GetRoot().(kDBSym).viewCObject then        		begin       			local isReggie := GetRoot().(kDBSym):DB_Kakunin();       			if not isReggie then       				regBtn:Open();       		end;       end,     iSeparator:       begin           local r := MakePixFamily(           GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource: }),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename:                   "Unix:Dash-Board-for-Newton-OS:Dash Board Prefs:DBPrefs.rsrc"                   , resource: 150}),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":(\u000E\ud\u00ED00BF", resource:                    }),             bitDepth: 8}]);           r.mask := CalculateMask(r.bits);           SetClass(r.mask, 'mask);           r;           end,     PackManEntryValScript:       func(app,soup,scriptframe)  ///modified version of dan rowley's script       begin               local dogenerateuniqueid:=func()         begin          local check;          local isunique;          repeat           check:=""&timeinseconds()&":"&ticks();           isunique:=call checkuniqueid with (check);          until isunique;          return intern(check);         end;                 local checkuniqueid:=func(id)         begin          if (not (isstring(id) or issymbol(id))) or (isstring(id) and       strlen(id)<1) then return nil;          if not soup then return true;          local idsym;          if issymbol(id) then           idsym:=id;          else           idsym:=intern(""&id);          local idcur:=soup:query({indexpath: ['name, 'date] , beginkey: [scriptframe.name, NIL] , endkey: [scriptframe.name, NIL]});          local entry;          entry:=idcur:entry();          if entry and entry.id=idsym then           return nil;          else           return true;         end;               if not app.skipcount then app.skipcount:=0;        if not app.updatecount then app.updatecount:=0;        if not app.newcount then app.newcount:=0;                if not scriptframe.id then return nil;               local cur:=soup:query({indexpath: ['name, 'date]});                      local entry:=cur:gotokey([scriptframe.name, NIL]);        if entry and StrEqual(entry.name, scriptFrame.name) and (entry.id = scriptFrame.id) then        begin //matching id and name!         local relation;         local confirmed:=nil;                             if not entry.version or not scriptframe.version or entry.version=scriptframe.version then           relation:=" similar";         else if entry.version > scriptframe.version then          relation:=" newer";         else           confirmed:='overwrite;                  if not confirmed then          confirmed:=modalconfirm("A"&relation&" script ("&entry.name&") with the same id as this script ("&scriptframe.name&") already exists .  Do you want to overwrite it, create a new"&                  " id for this script, or skip it?",                 [{ text:"Overwrite",value:'overwrite}, {text:"New ID", value:'newid}, {text:"Skip", value:'cancel}]);                if confirmed='overwrite then         begin           app.updatecount:=app.updatecount+1;          entryremovefromsoup(entry);          return true;         end;         else if confirmed='newid then         begin          scriptframe.id:=call dogenerateuniqueid with ();          app.newcount:=app.newcount+1;          return true;         end;         else         begin          app.skipcount:=app.skipcount+1;          return nil;         end;        end;        else //no matching id!        begin         app.newcount:=app.newcount+1;         return true;        end;               end;,     GetNMenuSpecials:       func(menuStuff)  //if menu Stuff then add shit for menu (i.e., specialSubmenus, etc).       begin       	local sPopup :=        		[       			{item: "Close Dash Board", icon: GetRoot().|DashBoard:FiveSpeed|.iClose, indent: 18, data: {type: 'cmd, data: 'cmdQuit, icon: 'iClose, submenu: NIL, text: "Close Dash Board"}},       			{item: "Dash Board Prefs", icon: GetRoot().|DashBoard:FiveSpeed|.iPrefs, indent: 18, data: {type: 'cmd, data: 'cmdPrefs, icon: 'iPrefs, submenu: NIL, text: "Dash Board Prefs"}},       			'pickseparator       		];       		       	foreach i in GetRoot().|DashBoard:FiveSpeed|.db_SpecialItems do       		begin       			AddArraySlot(sPopup, {item: i.text, icon: GetRoot().|DashBoard:FiveSpeed|.(i.icon), indent: 18, data: i});       		end;       		       	if menuStuff then       		begin       			AddArraySLot(sPopup, 'pickseparator);       			AddArraySlot(sPopup, {item: "Menu Separator", icon: iSeparator, indent: 18, data: {type: 'separator, text: "", submenu: NIL, data: nil, icon: 'iNone}});       			AddArraySlot(sPopup, 'pickSeparator);       			AddArraySlot(sPopup, {item: "All Scripts Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iScript, indent: 18, data: {type: 'dynSub, data: 'dynScripts, icon: 'iScript, submenu: TRUE, text: "All Scripts"}  });       			AddArraySlot(sPopup, {item: "All Special Items Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iSpecials, indent: 18, data: {type: 'dynSub, data: 'dynSpecials, icon: 'iSpecials, submenu: TRUE, text: "All Special Items"}});       			AddArraySlot(sPopup, {item: "Books Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iBook, indent: 18, data: {type: 'dynSub, data: 'dynBooks, icon: 'iBook, submenu: TRUE, text: "Books"}});       			AddArraySlot(sPopup, {item: "Extras Drawer Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iExtras, indent: 18, data: {type: 'dynSub, data: 'dynExtras, icon: 'iExtras, submenu: TRUE, text: "Extras Drawer"}  });       			AddArraySlot(sPopup, {item: "Recent Apps Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iRecent, indent: 18, data: {type: 'dynSub, data: 'dynRecent, icon: 'iRecent, submenu: TRUE, text: "Recent Apps"}});       			AddArraySlot(sPopup, {item: "Running Apps Submenu", icon: GetRoot().|DashBoard:FiveSpeed|.iRunning, indent: 18, data: {type: 'dynSub, data: 'dynRunning, icon: 'iRunning, submenu: TRUE, text: "Running Apps"}  });       			       	       		end;       	       	return sPopup;       	//return Sort(sPopup, '|str<|, 'item);       end,     WasWere:       func(x)       begin       	if x = 1 then "was" else "were";       end,     GetScriptSoupRef:       func()       begin       	if debugOn then       		begin       			local sT := Ticks();       		end;       	       	local mySoupDef := {name: "DashBoardPrefs:FiveSpeed",       		userName: "Dash Board Scripts",       		ownerApp: '|DashBoardPrefs:FiveSpeed|,       		ownerAppName : "Dash Board",       		userDescr: "This soup is where Dash Board's user scripts are stored.",       		indexes: [       					{structure: 'multiSlot, path: ['name, 'date], type: ['string, 'int]}       				],       		};       		       		       	       	local myUsoup := RegUnionSoup(kAppSymbol, mySoupDef);       	       		       	return myUsoup;       end,     menuItemDragBox: SetBounds(0,20,-100,0)    };Pane2 :=    {viewBounds: {left: 5, top: 23, right: -5, bottom: -20},     viewFlags: 33,     viewFormat: 0,     SwitchTab:       func(tabSym)       begin       	if tabSym <> 'menu then newtMenuTab:TabDeactivate();       	if tabSym <> 'launcher then letterLauncherTab:TabDeactivate();       	if tabSym <> 'scripts then scriptsTab:TabDeactivate();       	if tabSym <> 'misc then miscTab:TabDeactivate();       	       	       end,     viewSetupChildrenScript:       func()       begin       	if not GetRoot().(kAppSymbol).myPrefs.dbInited then return;              	newtmenuTab.myPanel := panelholder.newtMenuPanel;       	letterLauncherTab.myPanel := panelholder.letterLauncherPanel;       	scriptsTab.myPanel := panelholder.scriptsPanel;       	miscTab.myPanel := panelholder.miscPanel;       	       	//AddDeferredSend(newtMenuTab, 'TabActivateTabOnly, nil);  //moveed to viewSetupDone script in 1.2b1       end,     viewJustify: 240,     viewSetupDoneScript:       func()       begin       	//AddDeferredSend(newtMenuTab, 'TabActivateTabOnly, nil);       	newtMenuTab:TabActivateTabOnly();   /////////above was causing crash on show btn bar, cuz of the fact that DB closes prefs when it closes; prefs was closed when deferred send called       end,     viewClass: 74 /* clView */    };AddStepForm(DashBoardPrefs, Pane2);StepDeclare(DashBoardPrefs, Pane2, 'Pane2);panelHolder :=    {viewBounds: {left: 2, top: 17, right: -2, bottom: -2},     viewFlags: 1,     viewFormat: 593,     viewJustify: 240,     OpenPanel:       func(pSym)       begin       	if pSym = 'menu then       		begin       			NewtMenuPanel:Open();       			LetterLauncherPanel:Close();       			scriptsPanel:Close();       			miscPanel:Close();       		end       	else if pSym = 'launcher then       		begin       			LetterLauncherPanel:Open();       			NewtMenuPanel:Close();       			scriptsPanel:Close();       			miscPanel:Close();       		end       	else if pSym = 'scripts then       		begin       			scriptsPanel:Open();       			NewtMenuPanel:Close();       			LetterLauncherPanel:Close();       			miscPanel:Close();       		end       	else if pSym = 'misc then       		begin       			miscPanel:Open();       			LetterLauncherPanel:Close();       			scriptsPanel:Close();       			NewtMenuPanel:Close();       		end;       end,     viewClass: 74 /* clView */    };AddStepForm(Pane2, panelHolder);StepDeclare(Pane2, panelHolder, 'panelHolder);letterLauncherPanel := LinkedSubview(letterLauncherPanel,    {viewBounds: {left: 33, top: 11, right: 49, bottom: 27}});AddStepForm(panelHolder, letterLauncherPanel);StepDeclare(panelHolder, letterLauncherPanel, 'letterLauncherPanel);scriptsPanel := LinkedSubview(scriptPanel,    {viewBounds: {left: 57, top: 11, right: 73, bottom: 27}});AddStepForm(panelHolder, scriptsPanel);StepDeclare(panelHolder, scriptsPanel, 'scriptsPanel);miscPanel := LinkedSubview(miscPanel,    {viewBounds: {left: 81, top: 11, right: 97, bottom: 27}});AddStepForm(panelHolder, miscPanel);StepDeclare(panelHolder, miscPanel, 'miscPanel);newtMenuPanel := LinkedSubview(newtMenuPanel,    {viewBounds: {left: 9, top: 11, right: 25, bottom: 27}});AddStepForm(panelHolder, newtMenuPanel);StepDeclare(panelHolder, newtMenuPanel, 'newtMenuPanel);newtMenuTab :=    {viewBounds: {left: 0, top: 0, right: 79, bottom: 17},     tabText: "Menu",     mySym: 'menu,     _proto: myTab    };AddStepForm(Pane2, newtMenuTab);StepDeclare(Pane2, newtMenuTab, 'newtMenuTab);letterLauncherTab :=    {viewBounds: {left: 77, top: 0, right: 156, bottom: 17},     tabText: "Launcher",     mySym: 'launcher,     _proto: myTab    };AddStepForm(Pane2, letterLauncherTab);StepDeclare(Pane2, letterLauncherTab, 'letterLauncherTab);scriptsTab :=    {viewBounds: {left: 154, top: 0, right: 233, bottom: 17},     tabText: "Scripts",     mySym: 'scripts,     _proto: myTab    };AddStepForm(Pane2, scriptsTab);StepDeclare(Pane2, scriptsTab, 'scriptsTab);miscTab :=    {viewBounds: {left: 231, top: 0, right: 310, bottom: 17},     tabText: "Misc.",     mySym: 'misc,     _proto: myTab    };AddStepForm(Pane2, miscTab);StepDeclare(Pane2, miscTab, 'miscTab);barHider :=    {viewBounds: {left: 0, top: -20, right: 0, bottom: 0},     viewFlags: 1,     viewFormat: 1,     viewJustify: 176,     viewClass: 74 /* clView */    };AddStepForm(DashBoardPrefs, barHider);saveBtn :=    {     buttonClickScript:       func()       begin       	:ExportPrefsToDB();       	GetRoot().(kAppSymbol):Close();       end,     text: "Save",     viewBounds: {left: -52, top: -16, right: -7, bottom: -3},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(barHider, saveBtn);cancelBtn :=    {     buttonClickScript:       func()       begin       	GetRoot().(kAppSymbol):Close();       end,     text: "Cancel",     viewBounds: {left: -104, top: -16, right: -59, bottom: -3},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(barHider, cancelBtn);barHider_v218_0 :=    {text: "1999 Five Speed Software, Inc.",     viewBounds: {left: 61, top: 0, right: 214, bottom: 16},     viewFont: {family: 'geneva, face: kFaceNormal, size: 9, color: kRGB_Gray9},     viewJustify: 8388616,     _proto: @218 /* protoStaticText */    };AddStepForm(barHider, barHider_v218_0);validateBtn :=    {     buttonClickScript:       func()       begin       	:hilite(nil);       	:ValidatePrefs();       end,     text: "Validate",     viewBounds: {left: 7, top: -16, right: 57, bottom: -3},     viewJustify: 8388742,     _proto: @226 /* protoTextButton */    };AddStepForm(barHider, validateBtn);subOpts := LinkedSubview(subOpts,    {viewBounds: {left: 168, top: 0, right: 176, bottom: 8}});AddStepForm(DashBoardPrefs, subOpts);StepDeclare(DashBoardPrefs, subOpts, 'subOpts);LLedit := LinkedSubview(shortcutEdit,    {viewBounds: {left: 184, top: 0, right: 192, bottom: 8}});AddStepForm(DashBoardPrefs, LLedit);StepDeclare(DashBoardPrefs, LLedit, 'LLedit);modalator := LinkedSubview(modalator,    {viewBounds: {left: 184, top: 16, right: 192, bottom: 24}});AddStepForm(DashBoardPrefs, modalator);StepDeclare(DashBoardPrefs, modalator, 'modalator);scriptEditor := LinkedSubview(scriptEditor,    {viewBounds: {left: 152, top: 16, right: 160, bottom: 24}});AddStepForm(DashBoardPrefs, scriptEditor);StepDeclare(DashBoardPrefs, scriptEditor, 'scriptEditor);DashBoardPrefs_v218_0 :=    {text: "v." && kVsn,     viewBounds: {left: -66, top: 1, right: -5, bottom: 16},     viewFont: simpleFont9,     viewJustify: 8388641,     _proto: @218 /* protoStaticText */    };AddStepForm(DashBoardPrefs, DashBoardPrefs_v218_0);fileSlip := LinkedSubview(fileSlip,    {viewBounds: {left: 200, top: 0, right: 208, bottom: 16}});AddStepForm(DashBoardPrefs, fileSlip);StepDeclare(DashBoardPrefs, fileSlip, 'fileSlip);validator := LinkedSubview(validator,    {viewBounds: {left: 224, top: 8, right: 240, bottom: 16}});AddStepForm(DashBoardPrefs, validator);StepDeclare(DashBoardPrefs, validator, 'validator);PFWTDSlip := LinkedSubview(_v179_0,    {viewBounds: {left: 136, top: 8, right: 144, bottom: 16}});AddStepForm(DashBoardPrefs, PFWTDSlip);StepDeclare(DashBoardPrefs, PFWTDSlip, 'PFWTDSlip);regBtn :=    {     buttonClickScript:       func()       begin       	if GetRoot().(kDBSym).viewCObject then GetRoot().(kDBSym):cmdRegister();       end,     text: "Register",     viewBounds: {left: 7, top: 5, right: 65, bottom: 18},     viewFlags: 514,     _proto: @226 /* protoTextButton */    };AddStepForm(DashBoardPrefs, regBtn);StepDeclare(DashBoardPrefs, regBtn, 'regBtn);PackManNameSlip := LinkedSubview(PackManNameSlip,    {viewBounds: {left: 104, top: 0, right: 112, bottom: 16}});AddStepForm(DashBoardPrefs, PackManNameSlip);StepDeclare(DashBoardPrefs, PackManNameSlip, 'PackManNameSlip);constant |layout_main.t| := DashBoardPrefs;// End of file main.t